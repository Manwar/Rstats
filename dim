t/vector-nan.t:# nan - nan is double
t/vector-nan.t:  ok($nan->is_double);
t/vector-nan.t:  ok($nan2->is_nan->value);
t/vector-nan.t:# non - to_string
t/vector-na.t:  ok($na->is_na);
t/vector-na.t:  ok($na2->is_na);
t/vector-na.t:  ok($na->is_na);
t/array-mode.t:  # array decide mode - complex
t/array-mode.t:    my $x0 = r->complex(3, 4);
t/array-mode.t:    is($x1->values->[0]->{re}, 1);
t/array-mode.t:    is($x1->values->[0]->{im}, 0);
t/array-mode.t:    is($x1->values->[1]->{re}, 3);
t/array-mode.t:    is($x1->values->[1]->{im}, 4);
t/array-mode.t:    ok(r->is_complex($x1));
t/array-mode.t:  # is_* - is_array
t/array-mode.t:    ok(r->is_array($x));
t/array-mode.t:    ok(!r->is_vector($x));
t/array-mode.t:    ok(!r->is_matrix($x));
t/array-mode.t:  # is_* - is_matrix
t/array-mode.t:    ok(r->is_matrix($x));
t/array-mode.t:    ok(r->is_array($x));
t/array-mode.t:  # is_* - is_vector
t/array-mode.t:    ok(r->is_vector($x));
t/array-mode.t:    ok(!r->is_array($x));
t/array-mode.t:  # is_* - is_vector
t/array-mode.t:    ok(!r->is_vector($x));
t/array-mode.t:    ok(r->is_array($x));
t/array-mode.t:  # as_character - complex
t/array-mode.t:    my $x0 = r->complex(1, 2);
t/array-mode.t:    my $x1 = array(r->complex(1, 2));
t/array-mode.t:    my $x2 = r->as_character($x1);
t/array-mode.t:    ok(r->is_character($x2));
t/array-mode.t:    is($x2->values->[0], "1+2i");
t/array-mode.t:  # as_character - NA
t/array-mode.t:    my $x2 = r->as_character($x1);
t/array-mode.t:    ok(r->is_character($x2));
t/array-mode.t:    is_deeply($x2->values, [undef]);
t/array-mode.t:  # as_character - Inf
t/array-mode.t:    my $x2 = r->as_character($x1);
t/array-mode.t:    ok(r->is_character($x2));
t/array-mode.t:    is_deeply($x2->values, ["Inf"]);
t/array-mode.t:  # as_character - NaN
t/array-mode.t:    my $x2 = r->as_character($x1);
t/array-mode.t:    ok(r->is_character($x2));
t/array-mode.t:    is_deeply($x2->values, ["NaN"]);
t/array-mode.t:  # as_character - character
t/array-mode.t:    my $x2 = r->as_character($x1);
t/array-mode.t:    ok(r->is_character($x2));
t/array-mode.t:    is($x2->values->[0], "a");
t/array-mode.t:  # as_character - complex, 0 + 0i
t/array-mode.t:    my $x1 = array(r->complex(0, 0));
t/array-mode.t:    my $x2 = r->as_character($x1);
t/array-mode.t:    ok(r->is_character($x2));
t/array-mode.t:    is($x2->values->[0], "0+0i");
t/array-mode.t:  # as_character - numeric
t/array-mode.t:    my $x2 = r->as_character($x1);
t/array-mode.t:    ok(r->is_character($x2));
t/array-mode.t:    is($x2->values->[0], 1.1);
t/array-mode.t:    is($x2->values->[1], "0");
t/array-mode.t:  # as_character - logical
t/array-mode.t:    my $x2 = r->as_character($x1);
t/array-mode.t:    ok(r->is_character($x2));
t/array-mode.t:    is($x2->values->[0], "TRUE");
t/array-mode.t:    is($x2->values->[1], "FALSE");
t/array-mode.t:  # as_logical - Inf
t/array-mode.t:    my $x2 = r->as_logical($x1);
t/array-mode.t:    ok(r->is_logical($x2));
t/array-mode.t:    is_deeply($x2->values, [1]);
t/array-mode.t:  # as_logical - NA
t/array-mode.t:    my $x2 = r->as_logical($x1);
t/array-mode.t:    ok(r->is_logical($x2));
t/array-mode.t:    is_deeply($x2->values, [undef]);
t/array-mode.t:  # as_logical - NaN
t/array-mode.t:    my $x2 = r->as_logical($x1);
t/array-mode.t:    ok(r->is_logical($x2));
t/array-mode.t:    is_deeply($x2->values, [undef]);
t/array-mode.t:  # as_logical - character, number
t/array-mode.t:    my $x2 = r->as_logical($x1);
t/array-mode.t:    ok(r->is_logical($x2));
t/array-mode.t:    is($x2->values->[0], undef);
t/array-mode.t:  # as_logical - character, pre and trailing space
t/array-mode.t:    my $x2 = r->as_logical($x1);
t/array-mode.t:    ok(r->is_logical($x2));
t/array-mode.t:    is($x2->values->[0], undef);
t/array-mode.t:  # as_logical - character
t/array-mode.t:    my $x2 = r->as_logical($x1);
t/array-mode.t:    ok(r->is_logical($x2));
t/array-mode.t:    is($x2->values->[0], undef);
t/array-mode.t:  # as_logical - complex
t/array-mode.t:    my $x1 = array(r->complex(1, 2));
t/array-mode.t:    my $x2 = r->as_logical($x1);
t/array-mode.t:    ok(r->is_logical($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:  # as_logical - complex, 0 + 0i
t/array-mode.t:    my $x1 = array(r->complex(0, 0));
t/array-mode.t:    my $x2 = r->as_logical($x1);
t/array-mode.t:    ok(r->is_logical($x2));
t/array-mode.t:    is($x2->values->[0], 0);
t/array-mode.t:  # as_logical - numeric
t/array-mode.t:    my $x2 = r->as_logical($x1);
t/array-mode.t:    ok(r->is_logical($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:    is($x2->values->[1], 0);
t/array-mode.t:  # as_logical - logical
t/array-mode.t:    my $x2 = r->as_logical($x1);
t/array-mode.t:    ok(r->is_logical($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:    is($x2->values->[1], 0);
t/array-mode.t:  # as_integer - Inf
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is_deeply($x2->values, [undef]);
t/array-mode.t:  # as_integer - NA
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is_deeply($x2->values, [undef]);
t/array-mode.t:  # as_integer - NaN
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is_deeply($x2->values, [undef]);
t/array-mode.t:  # as_integer - character, only real number, no sign
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:  # as_integer - character, only real number, plus
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:  # as_integer - character, only real number, minus
t/array-mode.t:    my $x1 = array(c("-1.23"));
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is($x2->values->[0], -1);
t/array-mode.t:  # as_integer - character, pre and trailing space
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:  # as_integer - error
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is($x2->values->[0], undef);
t/array-mode.t:  # as_integer - complex
t/array-mode.t:    my $x1 = array(r->complex(1, 2));
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:  # as_integer - integer
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:  # as_integer - integer
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:  # as_integer - logical
t/array-mode.t:    my $x2 = r->as_integer($x1);
t/array-mode.t:    ok(r->is_integer($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:    is($x2->values->[1], 0);
t/array-mode.t:  # as_numeric - Inf
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is_deeply($x2->values, ['Inf']);
t/array-mode.t:  # as_numeric - NA
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is_deeply($x2->values, [undef]);
t/array-mode.t:  # as_numeric - NaN
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is_deeply($x2->values, ['NaN']);
t/array-mode.t:  # as_numeric - character, only real number, no sign
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is($x2->values->[0], 1.23);
t/array-mode.t:  # as_numeric - character, only real number, plus
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is($x2->values->[0], 1.23);
t/array-mode.t:  # as_numeric - character, only real number, minus
t/array-mode.t:    my $x1 = array("-1.23");
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is($x2->values->[0], -1.23);
t/array-mode.t:  # as_numeric - character, pre and trailing space
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:  # as_numeric - error
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is($x2->values->[0], undef);
t/array-mode.t:  # as_numeric - complex
t/array-mode.t:    my $x1 = array(r->complex(1, 2));
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:  # as_numeric - numeric
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is($x2->values->[0], 1.1);
t/array-mode.t:  # as_numeric - integer
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:  # as_numeric - logical
t/array-mode.t:    my $x2 = r->as_numeric($x1);
t/array-mode.t:    ok(r->is_numeric($x2));
t/array-mode.t:    is($x2->values->[0], 1);
t/array-mode.t:    is($x2->values->[1], 0);
t/array-mode.t:  # as_complex - Inf
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 'Inf');
t/array-mode.t:    is($x2->values->[0]->{im}, 0);
t/array-mode.t:  # as_complex - NA
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is_deeply($x2->values, [undef]);
t/array-mode.t:  # as_complex - NaN
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is_deeply($x2->values, [undef]);
t/array-mode.t:  # as_complex - character, only real number, no sign
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 1.23);
t/array-mode.t:    is($x2->values->[0]->{im}, 0);
t/array-mode.t:  # as_complex - character, only real number, pre and trailing space
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 1.23);
t/array-mode.t:    is($x2->values->[0]->{im}, 0);
t/array-mode.t:  # as_complex - character, only real number, plus
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 1.23);
t/array-mode.t:    is($x2->values->[0]->{im}, 0);
t/array-mode.t:  # as_complex - character, only real number, minus
t/array-mode.t:    my $x1 = array("-1.23");
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, -1.23);
t/array-mode.t:    is($x2->values->[0]->{im}, 0);
t/array-mode.t:  # as_complex - character, only image number, no sign
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 0);
t/array-mode.t:    is($x2->values->[0]->{im}, 1.23);
t/array-mode.t:  # as_complex - character, only image number, plus
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 0);
t/array-mode.t:    is($x2->values->[0]->{im}, 1.23);
t/array-mode.t:  # as_complex - character, only image number, minus
t/array-mode.t:    my $x1 = array("-1.23i");
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 0);
t/array-mode.t:    is($x2->values->[0]->{im}, -1.23);
t/array-mode.t:  # as_complex - character, real number and image number, no sign
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 2.5);
t/array-mode.t:    is($x2->values->[0]->{im}, 1.23);
t/array-mode.t:  # as_complex - character, real number and image number, plus
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 2.5);
t/array-mode.t:    is($x2->values->[0]->{im}, 1.23);
t/array-mode.t:  # as_complex - character, real number and image number, minus
t/array-mode.t:    my $x1 = array("-2.5-1.23i");
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, -2.5);
t/array-mode.t:    is($x2->values->[0]->{im}, -1.23);
t/array-mode.t:  # as_complex - character, pre and trailing space
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 2.5);
t/array-mode.t:    is($x2->values->[0]->{im}, 1.23);
t/array-mode.t:  # as_complex - error
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0], undef);
t/array-mode.t:  # as_complex - error
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0], undef);
t/array-mode.t:  # as_complex - complex
t/array-mode.t:    my $x1 = array(r->complex(1, 2));
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 1);
t/array-mode.t:    is($x2->values->[0]->{im}, 2);
t/array-mode.t:  # as_complex - numeric
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 1.1);
t/array-mode.t:    is($x2->values->[0]->{im}, 0);
t/array-mode.t:  # as_complex - integer
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 1);
t/array-mode.t:    is($x2->values->[0]->{im}, 0);
t/array-mode.t:  # as_complex - logical
t/array-mode.t:    my $x2 = r->as_complex($x1);
t/array-mode.t:    ok(r->is_complex($x2));
t/array-mode.t:    is($x2->values->[0]->{re}, 1);
t/array-mode.t:    is($x2->values->[0]->{im}, 0);
t/array-mode.t:    is($x2->values->[1]->{re}, 0);
t/array-mode.t:    is($x2->values->[1]->{im}, 0);
t/array-mode.t:  # array decide type - complex
t/array-mode.t:    my $x1 = array(c(r->complex(1, 2), r->complex(3, 4)));
t/array-mode.t:    is($x1->values->[0]->{re}, 1);
t/array-mode.t:    is($x1->values->[0]->{im}, 2);
t/array-mode.t:    is($x1->values->[1]->{re}, 3);
t/array-mode.t:    is($x1->values->[1]->{im}, 4);
t/array-mode.t:    ok(r->is_complex($x1));
t/array-mode.t:  # array decide type - numerci
t/array-mode.t:    is_deeply($x1->values, [1, 2]);
t/array-mode.t:    ok(r->is_numeric($x1));
t/array-mode.t:  # array decide type - logical
t/array-mode.t:    is_deeply($x1->values, [1, 0]);
t/array-mode.t:    ok(r->is_logical($x1));
t/array-mode.t:  # array decide type - character
t/array-mode.t:    is_deeply($x1->values, ["c1", "c2"]);
t/array-mode.t:    ok(r->is_character($x1));
t/array-mode.t:  # array decide type - character, look like number
t/array-mode.t:    is_deeply($x1->values, ["1", "2"]);
t/array-mode.t:    ok(r->is_character($x1));
t/array-mode.t:  # array decide type - Inf
t/array-mode.t:    is_deeply($x1->values, ['Inf']);
t/array-mode.t:    ok(r->is_numeric($x1));
t/array-mode.t:  # array decide type - NaN
t/array-mode.t:    is_deeply($x1->values, ['NaN']);
t/array-mode.t:    ok(r->is_numeric($x1));
t/array-mode.t:  # array decide type - NA
t/array-mode.t:    is_deeply($x1->values, [undef]);
t/array-mode.t:    ok(r->is_logical($x1));
t/array-mode.t:  # is_* - is_vector
t/array-mode.t:    ok(!r->is_vector($x));
t/array-mode.t:  # is_* - is_matrix
t/array-mode.t:    ok(r->is_matrix($x));
t/array-mode.t:  # is_* - is_array
t/array-mode.t:    ok(r->is_array($x));
t/array-mode.t:  # as_* - as_vector
t/array-mode.t:    is_deeply(r->as_vector($x)->values, [1 .. 24]);
t/array-mode.t:    is_deeply(r->dim(r->as_vector($x))->values, []);
t/array-mode.t:  # as_* - as_matrix, from vector
t/array-mode.t:    is_deeply(r->as_matrix($x)->values, [1 .. 24]);
t/array-mode.t:    is_deeply(r->dim(r->as_matrix($x))->values, [24, 1]);
t/array-mode.t:  # as_* - as_matrix, from matrix
t/array-mode.t:    is_deeply(r->as_matrix($x)->values, [1 .. 12]);
t/array-mode.t:    is_deeply(r->dim(r->as_matrix($x))->values, [4, 3]);
t/array-mode.t:  # as_* - as_matrix, from array
t/array-mode.t:    is_deeply(r->as_matrix($x)->values, [1 .. 24]);
t/array-mode.t:    is_deeply(r->dim(r->as_matrix($x))->values, [24, 1]);
t/array-mode.t:  # as_* from Rstats object - as_vector
t/array-mode.t:    is_deeply(r->as_vector($x)->values, [1 .. 24]);
t/array-mode.t:    is_deeply(r->dim(r->as_vector($x))->values, []);
t/array-mode.t:  # as_* from Rstats object - as_matrix, from vector
t/array-mode.t:    is_deeply(r->as_matrix($x)->values, [1 .. 24]);
t/array-mode.t:    is_deeply(r->dim(r->as_matrix($x))->values, [24, 1]);
t/array-mode.t:  # as_* from Rstats object - as_matrix, from matrix
t/array-mode.t:    is_deeply(r->as_matrix($x)->values, [1 .. 12]);
t/array-mode.t:    is_deeply(r->dim(r->as_matrix($x))->values, [4, 3]);
t/array-mode.t:  # as_* from Rstats object - as_matrix, from array
t/array-mode.t:    is_deeply(r->as_matrix($x)->values, [1 .. 24]);
t/array-mode.t:    is_deeply(r->dim(r->as_matrix($x))->values, [24, 1]);
t/array.t:#   get - logical, undef
t/array.t:  # bool context - one argument, false
t/array.t:  # bool context - two argument, true
t/array.t:  # bool context - two argument, true
t/array.t:    my $x1 = r->NULL;
t/array.t:  # array - basic
t/array.t:    is_deeply($x1->values, [1 .. 24]);
t/array.t:    is_deeply(r->dim($x1)->values, [4, 3, 2]);
t/array.t:  # array - dim option
t/array.t:    is_deeply($x1->values, [1 .. 24]);
t/array.t:    is_deeply(r->dim($x1)->values, [4, 3, 2]);
t/array.t:  # clone - matrix with value
t/array.t:    my $x1 = r->matrix(se('1:24'), 3, 2);
t/array.t:    my $x2 = $x1->clone;
t/array.t:    $x2->values([2 .. 25]);
t/array.t:    is_deeply($x2->values, [2 .. 25]);
t/array.t:  # clone - matrix
t/array.t:    my $x1 = r->matrix(se('1:24'), 3, 2);
t/array.t:    r->rownames($x1 => c('r1', 'r2', 'r3'));
t/array.t:    r->colnames($x1 => c('c1', 'c2'));
t/array.t:    my $x2 = $x1->clone;
t/array.t:    ok(r->is_matrix($x2));
t/array.t:    is_deeply(r->dim($x2)->values, [3, 2]);
t/array.t:    is_deeply(r->rownames($x2)->values, ['r1', 'r2', 'r3']);
t/array.t:    is_deeply(r->colnames($x2)->values, ['c1', 'c2']);
t/array.t:  # clone - vector
t/array.t:    my $x1 = r->matrix(se('1:24'), 3, 2);
t/array.t:    r->names($x1 => c('r1', 'r2', 'r3'));
t/array.t:    my $x2 = $x1->clone;
t/array.t:    is_deeply(r->names($x2)->values, ['r1', 'r2', 'r3']);
t/array.t:  # outer - basic
t/array.t:  my $x3 = r->outer($x1, $x2);
t/array.t:  is_deeply($x3->values, [qw/1  2  2  4  3  6  4  8  5 10  6 12  7 14  8 16  9 18 10 20 11 22 12 24/]);
t/array.t:  is_deeply(r->dim($x3)->values, [1, 2, 3, 4]);
t/array.t:  $x1->vector->to_string;
t/array.t:  # get logical array - basic
t/array.t:    my $x3 = $x1->get($x2);
t/array.t:    is_deeply($x3->values, [1, 5, 9]);
t/array.t:    is_deeply(r->dim($x3)->values, [3]);
t/array.t:  # numeric operator auto upgrade - complex
t/array.t:    my $x1 = array(c(r->complex(1,2), r->complex(3,4)));
t/array.t:    ok(r->is_complex($x3));
t/array.t:    is($x3->values->[0]->{re}, 2);
t/array.t:    is($x3->values->[0]->{im}, 2);
t/array.t:    is($x3->values->[1]->{re}, 5);
t/array.t:    is($x3->values->[1]->{im}, 4);
t/array.t:  # numeric operator auto upgrade - integer
t/array.t:    my $x1 = r->as_integer(c(3, 5));
t/array.t:    ok(r->is_integer($x3));
t/array.t:    is_deeply($x3->values, [4, 5])
t/array.t:  # numeric operator auto upgrade - numeric
t/array.t:    my $x2 = r->as_integer(array(c(1, 2)));
t/array.t:    ok(r->is_numeric($x3));
t/array.t:    is_deeply($x3->values, [2.1, 3.2])
t/array.t:  # numeric operator auto upgrade - character, +
t/array.t:    like($@, qr/non-numeric argument/);
t/array.t:  # numeric operator auto upgrade - character, -
t/array.t:    eval { my $ret = $x1 - $x2 };
t/array.t:    like($@, qr/non-numeric argument/);
t/array.t:  # numeric operator auto upgrade - character, *
t/array.t:    like($@, qr/non-numeric argument/);
t/array.t:  # numeric operator auto upgrade - character, /
t/array.t:    like($@, qr/non-numeric argument/);
t/array.t:  # numeric operator auto upgrade - character, ^
t/array.t:    like($@, qr/non-numeric argument/);
t/array.t:  # numeric operator auto upgrade - character, %
t/array.t:    like($@, qr/non-numeric argument/);
t/array.t:  # get - logical
t/array.t:    my $v2 = $v1->get($logical_v);
t/array.t:    is_deeply($v2->values, [3, 7, undef]);
t/array.t:  # get - have dimnames
t/array.t:    my $x1 = r->matrix(se('1:24'), 3, 2);
t/array.t:    r->dimnames($x1 => list(c('r1', 'r2', 'r3'), c('c1', 'c2')));
t/array.t:    my $x2 = $x1->get(c(1, 3), c(2));
t/array.t:    is_deeply($x2->dimnames->getin(1)->values, ['r1', 'r3']);
t/array.t:    is_deeply($x2->dimnames->getin(2)->values, ['c2']);
t/array.t:  # get - have names
t/array.t:    $v1->names(c("a", "b", "c"));
t/array.t:    my $v2 = $v1->get(c(1, 3));
t/array.t:    is_deeply($v2->values, [4, 6]);
t/array.t:    is_deeply($v2->names->values, ["a", "c"]);
t/array.t:  # get - one value
t/array.t:    my $v2 = $v1->get(1);
t/array.t:    is_deeply($v2->values, [1]);
t/array.t:    is_deeply(r->dim($v2)->values, [1]);
t/array.t:  # get - single index
t/array.t:    my $v2 = $v1->get(1);
t/array.t:    is_deeply($v2->values, [1]);
t/array.t:  # get - array
t/array.t:    my $v2 = $v1->get(c(1, 2));
t/array.t:    is_deeply($v2->values, [1, 3]);
t/array.t:  # get - vector
t/array.t:    my $v2 = $v1->get(c(1, 2));
t/array.t:    is_deeply($v2->values, [1, 3]);
t/array.t:  # get - minus number
t/array.t:    my $v2 = $v1->get(-1);
t/array.t:    is_deeply($v2->values, [3, 5, 7]);
t/array.t:  # get - minus number + array
t/array.t:    my $v2 = $v1->get(c(-1, -2));
t/array.t:    is_deeply($v2->values, [5, 7]);
t/array.t:  # get - character
t/array.t:    r->names($v1 => c('a', 'b', 'c', 'd'));
t/array.t:    my $v2 = $v1->get(c('b', 'd'));
t/array.t:    is_deeply($v2->values, [2, 4]);
t/array.t:  # get - grep
t/array.t:    my $v3 = $v1->get($v2);
t/array.t:    is_deeply($v3->values, [4, 5]);
t/array.t:  # get - as_logical
t/array.t:    my $logical_v = r->as_logical(c(0, 1, 0, 1, 1));
t/array.t:    my $v2 = $v1->get($logical_v);
t/array.t:    is_deeply($v2->values, [3, 7, undef]);
t/array.t:  # get - as_vector
t/array.t:    is_deeply(r->as_vector($x1)->get(5)->values, [5]);
t/array.t:  # get - as_matrix
t/array.t:    is_deeply(r->as_vector($x1)->get(5, 1)->values, [5]);
t/array.t:  # create element - double
t/array.t:  # create element - character
t/array.t:  # logical operator - &
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [qw/1 0 0 0/]);
t/array.t:  # logical operator - |
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [qw/1 1 1 0/]);
t/array.t:  # comparison operator - >
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [qw/0 0 1/]);
t/array.t:  # comparison operator - >=
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [qw/0 1 1/]);
t/array.t:  # comparison operator - <
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [qw/1 0 0/]);
t/array.t:  # comparison operator - <=
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [qw/1 1 0/]);
t/array.t:  # comparison operator - ==
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [qw/0 1 0/]);
t/array.t:  # comparison operator - !=
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [qw/1 0 1/]);
t/array.t:  # to_string - character, 1 dimention
t/array.t:  # to_string - character, 2 dimention
t/array.t:    my $x2 = r->as_character($x1);
t/array.t:  # to_string - character,3 dimention
t/array.t:    $x1 = r->as_character($x1);
t/array.t:  # to_string - one element
t/array.t:  # to_string - 2-dimention
t/array.t:  # to_string - 1-dimention
t/array.t:  # to_string - 1-dimention, as_vector
t/array.t:    my $x2 = r->as_vector($x1);
t/array.t:  # to_string - 1-dimention, as_matrix
t/array.t:    my $x2 = r->as_matrix($x1);
t/array.t:  # to_string - 1-dimention, TRUE, FALSE
t/array.t:    my $x1 = array(c(r->TRUE, r->FALSE));
t/array.t:  # to_string - 2-dimention
t/array.t:    my $x2 = r->as_matrix($x1);
t/array.t:  # to_string - 2-dimention, as_vector
t/array.t:    my $x2 = r->as_vector($x1);
t/array.t:  # to_string - 2-dimention, as_matrix
t/array.t:    my $x2 = r->as_matrix($x1);
t/array.t:  # to_string - 3-dimention
t/array.t:  # to_string - 3-dimention, as_vector
t/array.t:    my $x2 = r->as_vector($x1);
t/array.t:  # to_string - 3-dimention, as_matrix
t/array.t:    my $x2 = r->as_matrix($x1);
t/array.t:  # to_string - 4 dimention
t/array.t:  # set_diag - 3 x 3
t/array.t:    my $x2 = r->set_diag($x1, c(1, 2, 3));
t/array.t:    is_deeply($x1->values, [1, 4, 4, 4, 2, 4, 4, 4, 3]);
t/array.t:    is_deeply(r->dim($x1)->values, [3, 3]);
t/array.t:  # set_diag - repeat
t/array.t:    my $x2 = r->set_diag($x1, 1);
t/array.t:    is_deeply($x1->values, [1, 4, 4, 4, 1, 4, 4, 4, 1]);
t/array.t:    is_deeply(r->dim($x1)->values, [3, 3]);
t/array.t:  # set_diag - 2 x 3
t/array.t:    my $x2 = r->set_diag($x1, c(1, 2));
t/array.t:    is_deeply($x1->values, [1, 4, 4, 2, 4, 4]);
t/array.t:    is_deeply(r->dim($x1)->values, [2, 3]);
t/array.t:  # set_diag - 3 x 2
t/array.t:    my $x2 = r->set_diag($x1, c(1, 2));
t/array.t:    is_deeply($x1->values, [1, 4, 4, 4, 2, 4]);
t/array.t:    is_deeply(r->dim($x1)->values, [3, 2]);
t/array.t:  # diag - unit matrix
t/array.t:    my $x1 = r->diag(3);
t/array.t:    is_deeply($x1->values, [1, 0, 0, 0, 1, 0, 0, 0, 1]);
t/array.t:    is_deeply(r->dim($x1)->values, [3, 3]);
t/array.t:  # diag - basic
t/array.t:    my $x1 = r->diag(c(1, 2, 3));
t/array.t:    is_deeply($x1->values, [1, 0, 0, 0, 2, 0, 0, 0, 3]);
t/array.t:    is_deeply(r->dim($x1)->values, [3, 3]);
t/array.t:  # kronecker - basic
t/array.t:    my $x3 = r->kronecker($x1, $x2);
t/array.t:    is_deeply($x3->values, [
t/array.t:    is_deeply(r->dim($x3)->values, [12, 12, 2]);
t/array.t:  # kronecker - reverse
t/array.t:    my $x3 = r->kronecker($x1, $x2);
t/array.t:    is_deeply($x3->values, [
t/array.t:    is_deeply(r->dim($x3)->values, [12, 12, 2]);
t/array.t:  # comparison operator numeric - <
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [1, 0, 0]);
t/array.t:  # comparison operator numeric - <, arguments count is different
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [1, 0, 0]);
t/array.t:  # comparison operator numeric - <=
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [1, 0, 1]);
t/array.t:  # comparison operator numeric - <=, arguments count is different
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [1, 1, 0]);
t/array.t:  # comparison operator numeric - >
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [0, 1, 0]);
t/array.t:  # comparison operator numeric - >, arguments count is different
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [0, 0, 1]);
t/array.t:  # comparison operator numeric - >=
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [0, 1, 1]);
t/array.t:  # comparison operator numeric - >=, arguments count is different
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [0, 1, 1]);
t/array.t:  # comparison operator numeric - ==
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [0, 1]);
t/array.t:  # comparison operator numeric - ==, arguments count is different
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [0, 1]);
t/array.t:  # comparison operator numeric - !=
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [1, 0]);
t/array.t:  # comparison operator numeric - !=, arguments count is different
t/array.t:    ok(r->is_logical($x3));
t/array.t:    is_deeply($x3->values, [1, 0]);
t/array.t:  # operator - add to original vector
t/array.t:    $x1->at(r->length($x1) + 1)->set(6);
t/array.t:    is_deeply($x1->values, [1, 2, 3, 6]);
t/array.t:  # operator - negation
t/array.t:    my $x2 = -$x1;
t/array.t:    is_deeply($x2->values, [-1, -2, -3]);
t/array.t:  # operator - add
t/array.t:    is_deeply($v3->values, [3, 5, 7]);
t/array.t:  # operator - add(different element number)
t/array.t:    is_deeply($v3->values, [4, 6, 6, 8]);
t/array.t:  # operator - add(real number)
t/array.t:    is_deeply($x2->values, [2, 3, 4]);
t/array.t:  # operator - subtract
t/array.t:    my $v3 = $x1 - $x2;
t/array.t:    is_deeply($v3->values, [-2, -1, 0]);
t/array.t:  # operator - subtract(real number)
t/array.t:    my $x2 = $x1 - 1;
t/array.t:    is_deeply($x2->values, [0, 1, 2]);
t/array.t:  # operator - subtract(real number, reverse)
t/array.t:    my $x2 = 1 - $x1;
t/array.t:    is_deeply($x2->values, [0, -1, -2]);
t/array.t:  # operator - mutiply
t/array.t:    is_deeply($v3->values, [2, 6, 12]);
t/array.t:  # operator - mutiply(real number)
t/array.t:    is_deeply($x2->values, [2, 4, 6]);
t/array.t:  # operator - divide
t/array.t:    my $x1 = r->as_integer(c(6, 3, 12));
t/array.t:    my $x2 = r->as_integer(c(2, 3, 4));
t/array.t:    is_deeply($v3->values, [3, 1, 3]);
t/array.t:    ok(r->is_double($v3));
t/array.t:  # operator - divide
t/array.t:    is_deeply($v3->values, [3, 1, 3]);
t/array.t:  # operator - divide(real number)
t/array.t:    is_deeply($x2->values, [1, 2, 3]);
t/array.t:  # operator - divide(real number, reverse)
t/array.t:    is_deeply($x2->values, [1, 1/2, 1/3]);
t/array.t:  # operator - pow
t/array.t:    is_deeply($x2->values, [1, 4, 9]);
t/array.t:  # operator - pow, reverse
t/array.t:    is_deeply($x2->values, [2, 4, 8]);
t/array.t:  # operator - remainder
t/array.t:    is_deeply($x2->values, [1, 2, 0]);
t/array.t:  # operator - remainder, reverse
t/array.t:    is_deeply($x2->values, [0, 0, 2]);
t/array.t:  # operator - remainder, integer
t/array.t:    my $x1 = r->as_integer(c(1, 2, 3));
t/array.t:    my $x2 = r->as_integer(c(2, 2, 0));
t/array.t:    ok(r->is_integer($x3));
t/array.t:    is_deeply($x3->values, [1, 0, undef]);
t/array.t:  # value - none argument
t/array.t:    is($x1->value, 1);
t/array.t:  # value - one-dimetion
t/array.t:    is($x1->value(2), 2);
t/array.t:  # value - two-dimention
t/array.t:    is($x1->value(3, 2), 7);
t/array.t:  # value - two-dimention, as_vector
t/array.t:    is(r->as_vector($x1)->value(5), 5);
t/array.t:  # value - three-dimention
t/array.t:    is($x1->value(3, 2, 1), 7);
t/array.t:# set 3-dimention
t/array.t:  # set 3-dimention
t/array.t:    my $x2 = $x1->at(4, 3, 2)->set(25);
t/array.t:    is_deeply($x2->values, [1 .. 23, 25]);
t/array.t:  # set 3-dimention - one and tow dimention
t/array.t:    my $x2 = $x1->at(4, 3)->set(25);
t/array.t:    is_deeply($x2->values, [1 .. 11, 25, 13 .. 23, 25]);
t/array.t:  # set 3-dimention - one and tow dimention, value is two
t/array.t:    my $x2 = $x1->at(4, 3)->set(c(25, 26));
t/array.t:    is_deeply($x2->values, [1 .. 11, 25, 13 .. 23, 26]);
t/array.t:  # set 3-dimention - one and three dimention, value is three
t/array.t:    my $x2 = $x1->at(2, c(), 1)->set(c(31, 32, 33));
t/array.t:    is_deeply($x2->values, [1, 31, 3, 4, 5, 32, 7, 8, 9, 33, 11 .. 24]);
t/array.t:# get 3-dimention
t/array.t:  # get 3-dimention - minus
t/array.t:    my $x2 = $x1->get(c(-1, -2), c(-1, -2));
t/array.t:    is_deeply($x2->values, [11, 12, 23, 24]);
t/array.t:    is_deeply(r->dim($x2)->values, [2, 2]);
t/array.t:  # get 3-dimention - dimention one
t/array.t:    my $x2 = $x1->get(2);
t/array.t:    is_deeply($x2->values, [2, 6, 10, 14, 18 ,22]);
t/array.t:    is_deeply(r->dim($x2)->values, [3, 2]);
t/array.t:  # get 3-dimention - dimention two
t/array.t:    my $x2 = $x1->get(c(), 2);
t/array.t:    is_deeply($x2->values, [5, 6, 7, 8, 17, 18, 19, 20]);
t/array.t:    is_deeply(r->dim($x2)->values, [4, 2]);
t/array.t:  # get 3-dimention - dimention three
t/array.t:    my $x2 = $x1->get(c(), c(), 2);
t/array.t:    is_deeply($x2->values, [13 .. 24]);
t/array.t:    is_deeply(r->dim($x2)->values, [4, 3]);
t/array.t:  # get 3-dimention - one value
t/array.t:    my $x2 = $x1->get(3, 2, 1);
t/array.t:    is_deeply($x2->values, [7]);
t/array.t:    is_deeply(r->dim($x2)->values, [1]);
t/array.t:  # get 3-dimention - one value, drop => 0
t/array.t:    my $x2 = $x1->get(3, 2, 1, {drop => 0});
t/array.t:    is_deeply($x2->values, [7]);
t/array.t:    is_deeply(r->dim($x2)->values, [1, 1, 1]);
t/array.t:  # get 3-dimention - dimention one and two
t/array.t:    my $x2 = $x1->get(1, 2);
t/array.t:    is_deeply($x2->values, [5, 17]);
t/array.t:    is_deeply(r->dim($x2)->values, [2]);
t/array.t:  # get 3-dimention - dimention one and three
t/array.t:    my $x2 = $x1->get(3, c(), 2);
t/array.t:    is_deeply($x2->values, [15, 19, 23]);
t/array.t:    is_deeply(r->dim($x2)->values, [3]);
t/array.t:  # get 3-dimention - dimention two and three
t/array.t:    my $x2 = $x1->get(c(), 1, 2);
t/array.t:    is_deeply($x2->values, [13, 14, 15, 16]);
t/array.t:    is_deeply(r->dim($x2)->values, [4]);
t/array.t:  # get 3-dimention - all values
t/array.t:    my $x2 = $x1->get(c(1, 2, 3, 4), c(1, 2, 3), c(1, 2));
t/array.t:    is_deeply($x2->values, [1 .. 24]);
t/array.t:    is_deeply(r->dim($x2)->values, [4, 3, 2]);
t/array.t:  # get 3-dimention - all values 2
t/array.t:    my $x2 = $x1->get(c(1, 2, 3, 4), c(1, 2, 3), c(1, 2));
t/array.t:    is_deeply($x2->values, [map { $_ * 2 } (1 .. 24)]);
t/array.t:    is_deeply(r->dim($x2)->values, [4, 3, 2]);
t/array.t:  # get 3-dimention - some values
t/array.t:    my $x2 = $x1->get(c(2, 3), c(1, 3), c(1, 2));
t/array.t:    is_deeply($x2->values, [2, 3, 10, 11, 14, 15, 22, 23]);
t/array.t:    is_deeply(r->dim($x2)->values, [2, 2, 2]);
t/xs_element.t:  # element - new_na
t/xs_element.t:    ok($e1->is_na);
t/xs_element.t:    ok(!defined $e1->value);
t/xs_element.t:  # element - is_finite
t/xs_element.t:    # element - is_finite - double
t/xs_element.t:      ok($e1->is_finite);
t/xs_element.t:    # element - is_finite - integer
t/xs_element.t:      ok($e1->is_finite);
t/xs_element.t:    # element - is_finite - NaN
t/xs_element.t:      is($e1->type, 'double');
t/xs_element.t:      ok(!$e1->is_finite->value);
t/xs_element.t:    # element - is_finite - Inf
t/xs_element.t:      ok(!$e1->is_finite->value);
t/xs_element.t:    # element - is_finite - -Inf
t/xs_element.t:      ok(!$e1->is_finite->value);
t/xs_element.t:  # element - character_xs
t/xs_element.t:    is($e1->type, 'character');
t/xs_element.t:    is($e1->value, "foo");
t/xs_element.t:  # element - Inf_xs
t/xs_element.t:    is($e1->type, 'double');
t/xs_element.t:    ok($e1->is_infinite->value);
t/xs_element.t:    is($e1->value, 'Inf');
t/xs_element.t:  # element - negativeInf_xs
t/xs_element.t:    is($e1->type, 'double');
t/xs_element.t:    ok($e1->is_infinite->value);
t/xs_element.t:    is($e1->value, '-Inf');
t/xs_element.t:  # element - NaN_xs
t/xs_element.t:    is($e1->type, 'double');
t/xs_element.t:    ok($e1->is_nan);
t/xs_element.t:  # element - double_xs
t/xs_element.t:    is($e1->type, 'double');
t/xs_element.t:    is($e1->value, 2.5);
t/xs_element.t:  # element - integer_xs
t/xs_element.t:    is($e1->type, 'integer');
t/xs_element.t:    is($e1->value, 2);
t/xs_element.t:  # element - logical_xs
t/xs_element.t:    is($e1->type, 'logical');
t/xs_element.t:    is($e1->value, 1);
t/xs_element.t:  # element - complex_xs
t/xs_element.t:    is($e1->type, 'complex');
t/xs_element.t:    is($e1->value->{re}, 1.5);
t/xs_element.t:    is($e1->value->{im}, 2.5);
t/data_frame.t:  # set - NULL
t/data_frame.t:    $x1->at(2)->set(NULL);
t/data_frame.t:    is_deeply(r->as_character($x1->getin(1))->values, ['F', 'M', 'F']);
t/data_frame.t:    is_deeply($x1->getin(2)->values, [5, 6, 7]);
t/data_frame.t:    is_deeply($x1->names->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply($x1->colnames->values, ['sex', 'weight']);
t/data_frame.t:  # set - index
t/data_frame.t:    $x1->at(2)->set(c(1, 2, 3));
t/data_frame.t:    is_deeply($x1->getin('height')->values, [1, 2, 3]);
t/data_frame.t:  my $x2 = r->typeof($x1);
t/data_frame.t:  ok(r->is_character($x2));
t/data_frame.t:  is_deeply($x2->values, ['list']);
t/data_frame.t:  # get - multiple elements
t/data_frame.t:    my $x2 = $x1->get(c(1,3));
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->class->values, ['data.frame']);
t/data_frame.t:    is_deeply($x2->names->values, ['sex', 'weight']);
t/data_frame.t:    my $tmp = $x2->dimnames;
t/data_frame.t:    is_deeply($tmp->getin(2)->values, ['sex', 'weight']);
t/data_frame.t:  # get - minus row index
t/data_frame.t:    my $x2 = $x1->get(c(-1, -3), NULL);
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->getin(1)->values, [qw/2/]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [qw/168/]);
t/data_frame.t:    is_deeply($x2->getin(3)->values, [qw/6/]);
t/data_frame.t:  # get - minus collum index
t/data_frame.t:    my $x2 = $x1->get(NULL, c(-1, -3));
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->names->values, ['height']);
t/data_frame.t:    is_deeply($x2->getin(1)->values, [qw/172 168 155/]);
t/data_frame.t:  # get - row index and column index is null
t/data_frame.t:    my $x2 = $x1->get(c(3, 2), NULL);
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->class->values, ['data.frame']);
t/data_frame.t:    is_deeply($x2->names->values, ['sex', 'height', 'weight']);
t/data_frame.t:    is_deeply($x2->rownames->values, [qw/1 2/]);
t/data_frame.t:    is_deeply(r->as_character($x2->getin(1))->values, [qw/F M/]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [qw/155 168/]);
t/data_frame.t:    is_deeply($x2->getin(3)->values, [qw/7 6/]);
t/data_frame.t:  # get - row index and column index is null
t/data_frame.t:    my $x2 = $x1->get(c(3, 2), NULL);
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->class->values, ['data.frame']);
t/data_frame.t:    is_deeply($x2->names->values, ['sex', 'height', 'weight']);
t/data_frame.t:    is_deeply($x2->rownames->values, [qw/1 2/]);
t/data_frame.t:    is_deeply(r->as_character($x2->getin(1))->values, [qw/F M/]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [qw/155 168/]);
t/data_frame.t:    is_deeply($x2->getin(3)->values, [qw/7 6/]);
t/data_frame.t:  # get - row index and column index
t/data_frame.t:    my $x2 = $x1->get(c(3, 2), c(1, 3));
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->class->values, ['data.frame']);
t/data_frame.t:    is_deeply($x2->names->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply($x2->rownames->values, [qw/1 2/]);
t/data_frame.t:    is_deeply($x2->colnames->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply(r->as_character($x2->getin(1))->values, [qw/F M/]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [qw/7 6/]);
t/data_frame.t:  # get - logical, logical
t/data_frame.t:    my $x2 = $x1->get(c(T, F, T), c(T, F, T));
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->class->values, ['data.frame']);
t/data_frame.t:    is_deeply($x2->names->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply($x2->rownames->values, [qw/1 2/]);
t/data_frame.t:    is_deeply($x2->colnames->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply(r->as_character($x2->getin(1))->values, [qw/F F/]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [qw/5 7/]);
t/data_frame.t:  # get - logical
t/data_frame.t:    my $x2 = $x1->get(c(T, F, T));
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->class->values, ['data.frame']);
t/data_frame.t:    is_deeply($x2->names->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply($x2->rownames->values, [qw/1 2 3/]);
t/data_frame.t:    is_deeply($x2->colnames->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply(r->as_character($x2->getin(1))->values, [qw/F M F/]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [qw/5 6 7/]);
t/data_frame.t:  # get - row index and name
t/data_frame.t:    my $x2 = $x1->get(c(2, 3), c(1, 3));
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->class->values, ['data.frame']);
t/data_frame.t:    is_deeply($x2->names->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply($x2->rownames->values, [qw/1 2/]);
t/data_frame.t:    is_deeply($x2->colnames->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply(r->as_character($x2->getin(1))->values, [qw/M F/]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [qw/6 7/]);
t/data_frame.t:  # get - row index
t/data_frame.t:    my $x2 = $x1->get(NULL, c(1, 3));
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->class->values, ['data.frame']);
t/data_frame.t:    is_deeply($x2->names->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply($x2->rownames->values, [qw/1 2 3/]);
t/data_frame.t:    is_deeply($x2->colnames->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply(r->as_character($x2->getin(1))->values, [qw/F M F/]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [qw/5 6 7/]);
t/data_frame.t:  # get - name
t/data_frame.t:    my $x2 = $x1->get("weight");
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->class->values, ['data.frame']);
t/data_frame.t:    is_deeply($x2->names->values, ['weight']);
t/data_frame.t:  # transform - less elements
t/data_frame.t:    my $x2 = r->transform($x1, sex => c("P"));
t/data_frame.t:    is_deeply($x2->names->values, [qw/sex height weight/]);
t/data_frame.t:    is_deeply($x2->getin(1)->values, ["P", "P", "P", "P"]);
t/data_frame.t:  # transform - basic
t/data_frame.t:    my $x2 = r->transform($x1, sex => c("P", "Q", "P", "Q"), new1 => c(1, 2, 3, 4));
t/data_frame.t:    is_deeply($x2->names->values, [qw/sex height weight new1/]);
t/data_frame.t:    is_deeply($x2->getin(1)->values, ["P", "Q", "P", "Q"]);
t/data_frame.t:    is_deeply($x2->getin(4)->values, [1, 2, 3, 4]);
t/data_frame.t:  # subset - row condition
t/data_frame.t:    my $x2 = r->subset($x1, $x1->getin('height') > 160);
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->names->values, ['sex', 'height', 'weight']);
t/data_frame.t:    is_deeply(r->as_character($x2->getin(1))->values, [qw/F M/]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [qw/172 168/]);
t/data_frame.t:    is_deeply($x2->getin(3)->values, [qw/5 6/]);
t/data_frame.t:  # subset - row condition and column names
t/data_frame.t:    my $x2 = r->subset($x1, $x1->getin('height') > 160, c('sex', 'weight'));
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->names->values, ['sex', 'weight']);
t/data_frame.t:    is_deeply(r->as_character($x2->getin(1))->values, [qw/F M/]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [qw/5 6/]);
t/data_frame.t:  # data_frame - with I
t/data_frame.t:    my $sex = r->I(c('F', 'M', 'F'));
t/data_frame.t:    ok(r->is_character($x1->getin(1)));
t/data_frame.t:    is_deeply($x1->getin(1)->values, ["F", "M", "F"]);
t/data_frame.t:    is_deeply($x1->getin(2)->values, [172, 168, 155]);
t/data_frame.t:  # data_frame - basic
t/data_frame.t:    ok(r->is_factor($x1->getin(1)));
t/data_frame.t:    is_deeply($x1->getin(1)->values, [1, 2, 1]);
t/data_frame.t:    is_deeply($x1->getin('sex')->values, [1, 2, 1]);
t/data_frame.t:    is_deeply($x1->getin(2)->values, [172, 168, 155]);
t/data_frame.t:    is_deeply($x1->getin('height')->values, [172, 168, 155]);
t/data_frame.t:  # data_frame - alias for cbind
t/data_frame.t:    ok(r->is_data_frame($x3));
t/data_frame.t:    is_deeply($x3->class->values, ['data.frame']);
t/data_frame.t:    is_deeply($x3->names->values, ['sex', 'height', 'weight']);
t/data_frame.t:    ok(r->is_factor($x3->getin(1)));
t/data_frame.t:    is_deeply(r->as_character($x3->getin(1))->values, [qw/F M F/]);
t/data_frame.t:    is_deeply($x3->getin(2)->values, [172, 168, 155]);
t/data_frame.t:    is_deeply($x3->getin(3)->values, [5, 6, 7]);
t/data_frame.t:  # data_frame - basic
t/data_frame.t:    ok(r->is_factor($x1->getin(1)));
t/data_frame.t:    is_deeply($x1->getin(1)->values, [1, 2, 1]);
t/data_frame.t:    is_deeply($x1->getin('sex')->values, [1, 2, 1]);
t/data_frame.t:    is_deeply($x1->getin(2)->values, [172, 168, 155]);
t/data_frame.t:    is_deeply($x1->getin('height')->values, [172, 168, 155]);
t/data_frame.t:  # data_frame - name duplicate
t/data_frame.t:    is_deeply($x1->getin('sex')->values, [1, 2, 3]);
t/data_frame.t:    is_deeply(r->levels($x1->getin('sex'))->values, ['a', 'b', 'c']);
t/data_frame.t:    is_deeply($x1->getin('sex.1')->values, [1, 2, 3]);
t/data_frame.t:    is_deeply(r->levels($x1->getin('sex.1'))->values, ['a1', 'b1', 'c1']);
t/data_frame.t:    is_deeply($x1->getin('sex.2')->values, [1, 2, 3]);
t/data_frame.t:    is_deeply(r->levels($x1->getin('sex.2'))->values, ['a2', 'b2', 'c2']);
t/data_frame.t:  # na_omit - minus row index
t/data_frame.t:    my $x2 = r->na_omit($x1);
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->getin(1)->values, [qw/1/]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [qw/155/]);
t/data_frame.t:    is_deeply($x2->getin(3)->values, [qw/7/]);
t/data_frame.t:  # head - default
t/data_frame.t:    my $x2 = r->head($x1);
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->getin(1)->values, [1, 2, 3, 4, 5, 6]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [1, 2, 3, 4, 5, 10]);
t/data_frame.t:  # head - n
t/data_frame.t:    my $x2 = r->head($x1, {n => 3});
t/data_frame.t:    ok(r->is_data_frame($x2));
t/data_frame.t:    is_deeply($x2->getin(1)->values, [1, 2, 3]);
t/data_frame.t:    is_deeply($x2->getin(2)->values, [1, 2, 5]);
t/data_frame.t:  my $x3 = r->cbind($x1, $x2);
t/data_frame.t:  ok(r->is_data_frame($x3));
t/data_frame.t:  is_deeply($x3->class->values, ['data.frame']);
t/data_frame.t:  is_deeply($x3->names->values, ['sex', 'height', 'weight']);
t/data_frame.t:  ok(r->is_factor($x3->getin(1)));
t/data_frame.t:  is_deeply(r->as_character($x3->getin(1))->values, [qw/F M F/]);
t/data_frame.t:  is_deeply($x3->getin(2)->values, [172, 168, 155]);
t/data_frame.t:  is_deeply($x3->getin(3)->values, [5, 6, 7]);
t/data_frame.t:  my $x3 = r->rbind($x1, $x2);
t/data_frame.t:  ok(r->is_factor($x3->getin(1)));
t/data_frame.t:  is_deeply($x3->names->values, [qw/sex height/]);
t/data_frame.t:  is_deeply(r->as_character($x3->getin(1))->values, [qw/F M M F/]);
t/data_frame.t:  is_deeply($x3->getin(2)->values, [172, 168, 5, 6]);
t/data_frame.t:  my $x2 = r->ncol($x1);
t/data_frame.t:  ok($x2->values, [3]);
t/data_frame.t:  my $x2 = r->nrow($x1);
t/data_frame.t:  ok($x2->values, [2]);
t/data_frame.t:# data_frame - to_string
t/data_frame.t:  # data_frame - to_string
t/functions.t:    is_deeply($v2->values, [1, 2, 3, 4, 5]);
t/functions.t:    my $var = r->var($v1);
t/functions.t:    is($var->value, 8.5);
t/functions.t:    is_deeply($v1->values, [1, 2, 3, 4]);
t/functions.t:    $v1->at(r->length($v1)->value + 1)->set(6);
t/functions.t:    is_deeply($v1->values, [1, 2, 3, 6]);
t/functions.t:    my $v1 = r->numeric(3);
t/functions.t:    is_deeply($v1->values, [0, 0, 0]);
t/functions.t:    my $length = r->length($v1);
t/functions.t:    is($length->value, 3);
t/functions.t:    my $mean = r->mean($v1);
t/functions.t:    is($mean->value, 2);
t/functions.t:    # sort - acending
t/functions.t:      my $v1_sorted = r->sort($v1);
t/functions.t:      is_deeply($v1_sorted->values, [1, 2, 5]);
t/functions.t:    # sort - decreasing
t/functions.t:      my $v1_sorted = r->sort($v1, {decreasing => 1});
t/functions.t:      is_deeply($v1_sorted->values, [5, 2, 1]);
t/functions.t:    # sort - contain NA or NaN
t/functions.t:      my $v1_sorted = r->sort($v1);
t/functions.t:      is_deeply($v1_sorted->values, [1, 2, 5]);
t/functions.t:  # prod - complex
t/functions.t:    my $prod = r->prod($v1);
t/functions.t:    is_deeply($prod->values, [{re => -1, im => 5}]);
t/functions.t:  # prod - double
t/functions.t:    my $prod = r->prod($v1);
t/functions.t:    is_deeply($prod->values, [24]);
t/functions.t:  # prod - integer
t/functions.t:    my $v1 = r->as_integer(c(2, 3, 4));
t/functions.t:    my $prod = r->prod($v1);
t/functions.t:    is_deeply($prod->values, [24]);
t/functions.t:  # prod - logical
t/functions.t:    my $prod = r->prod($v1);
t/functions.t:    is_deeply($prod->values, [1]);
t/functions.t:  # sum - complex
t/functions.t:    my $x2 = r->sum($x1);
t/functions.t:    is_deeply($x2->values, [{re => 6, im => 6}]);
t/functions.t:  # sum - double
t/functions.t:    my $x2 = r->sum($x1);
t/functions.t:    is_deeply($x2->values, [6]);
t/functions.t:  # sum - integer
t/functions.t:    my $x1 = r->as_integer(c(1, 2, 3));
t/functions.t:    my $x2 = r->sum($x1);
t/functions.t:    is_deeply($x2->values, [6]);
t/functions.t:  # sum - logical
t/functions.t:    my $x2 = r->sum($x1);
t/functions.t:    is_deeply($x2->values, [2]);
t/functions.t:# ve - minus
t/functions.t:  my $x1 = -se('1:4');
t/functions.t:  is_deeply($x1->values, [-1, -2, -3, -4]);
t/functions.t:  # str - array, one element
t/functions.t:    is(r->str($x1), 'num [1(1d)] 1');
t/functions.t:  # str - array, one dimention
t/functions.t:    is(r->str($x1), 'num [1:4(1d)] 1 2 3 4');
t/functions.t:  # str - array
t/functions.t:    is(r->str($x1), 'num [1:4, 1:3] 1 2 3 4 5 6 7 8 9 10 ...');
t/functions.t:  # str - vector, more than 10 element
t/functions.t:    is(r->str($x1), 'num [1:11] 1 2 3 4 5 6 7 8 9 10 ...');
t/functions.t:  # str - vector, 10 element
t/functions.t:    is(r->str($x1), 'num [1:10] 1 2 3 4 5 6 7 8 9 10');
t/functions.t:  # str - vector, logical
t/functions.t:    is(r->str($x1), 'logi [1:2] TRUE FALSE');
t/functions.t:  # str - vector, integer
t/functions.t:    my $x1 = r->as_integer(c(1, 2));
t/functions.t:    is(r->str($x1), 'int [1:2] 1 2');
t/functions.t:  # str - vector, complex
t/functions.t:    is(r->str($x1), 'cplx [1:2] 1+1i 1+2i');
t/functions.t:  # str - vector, character
t/functions.t:    is(r->str($x1), 'chr [1:3] "a" "b" "c"');
t/functions.t:  # str - vector, one element
t/functions.t:    is(r->str($x1), 'num 1');
t/functions.t:  # str - vector, double
t/functions.t:    is(r->str($x1), 'num [1:3] 1 2 3');
t/functions.t:  # expm1 - complex
t/functions.t:      my $x2 = r->expm1($x1);
t/functions.t:  # expm1 - double,array
t/functions.t:    my $x2 = r->expm1($x1);
t/functions.t:    is(sprintf("%.6f", $x2->values->[0]), '1.718282');
t/functions.t:    is(sprintf("%.6f", $x2->values->[1]), '6.389056');
t/functions.t:    is_deeply(r->dim($x2)->values, [2]);
t/functions.t:    ok(r->is_double($x2));
t/functions.t:  # expm1 - double,less than 1e-5
t/functions.t:    my $x2 = r->expm1($x1);
t/functions.t:    my $x2_value_str = sprintf("%.13e", $x2->value);
t/functions.t:    $x2_value_str =~ s/e-0+/e-/;
t/functions.t:    is($x2_value_str, '1.2340000761378e-7');
t/functions.t:    ok(r->is_double($x2));
t/functions.t:  # expm1 - integer
t/functions.t:    my $x1 = r->as_integer(array(c(2)));
t/functions.t:    my $x2 = r->expm1($x1);
t/functions.t:    is(sprintf("%.6f", $x2->value), '6.389056');
t/functions.t:    ok(r->is_double($x2));
t/functions.t:  # expm1 - Inf
t/functions.t:    my $x2 = r->expm1($x1);
t/functions.t:    is($x2->value, 'Inf');
t/functions.t:  # expm1 - -Inf
t/functions.t:    my $x1 = c(-Inf);
t/functions.t:    my $x2 = r->expm1($x1);
t/functions.t:    is($x2->value, -1);
t/functions.t:  # expm1 - NA
t/functions.t:    my $x2 = r->expm1($x1);
t/functions.t:    ok(!defined $x2->value);
t/functions.t:  # expm1 - NaN
t/functions.t:    my $x2 = r->expm1($x1);
t/functions.t:    is($x2->value, 'NaN');
t/functions.t:  # exp - complex
t/functions.t:    my $x2 = r->exp($x1);
t/functions.t:    is(sprintf("%.6f", $x2->value->{re}), '-1.131204');
t/functions.t:    is(sprintf("%.6f", $x2->value->{im}), '2.471727');
t/functions.t:    ok(r->is_complex($x2));
t/functions.t:  # exp - double,array
t/functions.t:    my $x2 = r->exp($x1);
t/functions.t:    is(sprintf("%.6f", $x2->values->[0]), '2.718282');
t/functions.t:    is(sprintf("%.6f", $x2->values->[1]), '7.389056');
t/functions.t:    is_deeply(r->dim($x2)->values, [2]);
t/functions.t:    ok(r->is_double($x2));
t/functions.t:  # exp - Inf
t/functions.t:    my $x2 = r->exp($x1);
t/functions.t:    is($x2->value, 'Inf');
t/functions.t:  # exp - -Inf
t/functions.t:    my $x1 = c(-Inf);
t/functions.t:    my $x2 = r->exp($x1);
t/functions.t:    is($x2->value, 0);
t/functions.t:  # exp - NA
t/functions.t:    my $x2 = r->exp($x1);
t/functions.t:    ok(!defined $x2->value);
t/functions.t:  # exp - NaN
t/functions.t:    my $x2 = r->exp($x1);
t/functions.t:    is($x2->value, 'NaN');
t/functions.t:  # log10 - complex
t/functions.t:    my $x2 = r->log10($x1);
t/functions.t:    my $exp = Math::Complex->make(1, 2)->log / Math::Complex->make(10, 0)->log;
t/functions.t:    is($x2->value->{re}, $exp_re);
t/functions.t:    is($x2->value->{im}, $exp_im);
t/functions.t:    ok(r->is_complex($x2));
t/functions.t:  # log10 - double,array
t/functions.t:    my $x2 = r->log10($x1);
t/functions.t:    is($x2->value, 1);
t/functions.t:    is_deeply(r->dim($x2)->values, [1]);
t/functions.t:    ok(r->is_double($x2));
t/functions.t:  # log2 - complex
t/functions.t:    my $x2 = r->log2($x1);
t/functions.t:    my $exp = Math::Complex->make(1, 2)->log;
t/functions.t:    is($x2->value->{re}, $exp_re / log(2));
t/functions.t:    is($x2->value->{im}, $exp_im / log(2));
t/functions.t:    ok(r->is_complex($x2));
t/functions.t:  # log2 - double,array
t/functions.t:    my $x2 = r->log2($x1);
t/functions.t:    is($x2->values->[0], 1);
t/functions.t:    is_deeply(r->dim($x2)->values, [1]);
t/functions.t:    ok(r->is_double($x2));
t/functions.t:  # logb - complex
t/functions.t:    my $x2 = r->logb($x1);
t/functions.t:    my $exp = Math::Complex->make(1, 2)->log;
t/functions.t:    is($x2->value->{re}, $exp_re);
t/functions.t:    is($x2->value->{im}, $exp_im);
t/functions.t:    ok(r->is_complex($x2));
t/functions.t:  # logb - double,array
t/functions.t:    my $x1 = array(c(1, 10, -1, 0));
t/functions.t:    my $x2 = r->logb($x1);
t/functions.t:    is($x2->values->[0], 0);
t/functions.t:    is(sprintf("%.5f", $x2->values->[1]), '2.30259');
t/functions.t:    is($x2->values->[2], 'NaN');
t/functions.t:    ok($x2->values->[3], '-Inf');
t/functions.t:    is_deeply(r->dim($x2)->values, [4]);
t/functions.t:    ok(r->is_double($x2));
t/functions.t:  # log - complex
t/functions.t:    my $x2 = r->log($x1);
t/functions.t:    my $exp = Math::Complex->make(1, 2)->log;
t/functions.t:    is($x2->value->{re}, $exp_re);
t/functions.t:    is($x2->value->{im}, $exp_im);
t/functions.t:    ok(r->is_complex($x2));
t/functions.t:  # log - double,array
t/functions.t:    my $x1 = array(c(1, 10, -1, 0));
t/functions.t:    my $x2 = r->log($x1);
t/functions.t:    is($x2->values->[0], 0);
t/functions.t:    is(sprintf("%.5f", $x2->values->[1]), '2.30259');
t/functions.t:    ok($x2->values->[2], 'NaN');
t/functions.t:    ok($x2->values->[3], '-Inf');
t/functions.t:    is_deeply(r->dim($x2)->values, [4]);
t/functions.t:    ok(r->is_double($x2));
t/functions.t:  # log - Inf
t/functions.t:    my $x2 = r->log($x1);
t/functions.t:    ok(r->is_infinite($x2)->values, [1]);
t/functions.t:  # log - Inf()
t/functions.t:    my $x1 = c(-Inf);
t/functions.t:    my $x2 = r->log($x1);
t/functions.t:    is($x2->value, 'NaN');
t/functions.t:  # log - NA
t/functions.t:    my $x2 = r->log($x1);
t/functions.t:    ok(!defined $x2->value);
t/functions.t:  # log - NaN
t/functions.t:    my $x2 = r->log($x1);
t/functions.t:    is($x2->value, 'NaN');
t/functions.t:  # Arg - non 0 values
t/functions.t:    my $x2 = r->Arg($x1);
t/functions.t:    is_deeply($x2->values, [Rstats::Util::pi() / 4, Rstats::Util::pi() / 4]);
t/functions.t:  # Arg - 0 values
t/functions.t:    my $x2 = r->Arg($x1);
t/functions.t:    is_deeply($x2->values, [0]);
t/functions.t:  # sub - case not ignore
t/functions.t:    my $x4 = r->sub($x1, $x2, $x3);
t/functions.t:    is_deeply($x4->values, ["bd1ad1", undef, "bd2ad2"]);
t/functions.t:  # sub - case ignore
t/functions.t:    my $x4 = r->sub($x1, $x2, $x3, {'ignore.case' => TRUE});
t/functions.t:    is_deeply($x4->values, ["bd1ad1", undef, "bd2ad2"]);
t/functions.t:  # gsub - case not ignore
t/functions.t:    my $x4 = r->gsub($x1, $x2, $x3);
t/functions.t:    is_deeply($x4->values, ["bd1bd1", undef, "bd2bd2"]);
t/functions.t:  # sub - case ignore
t/functions.t:    my $x4 = r->gsub($x1, $x2, $x3, {'ignore.case' => TRUE});
t/functions.t:    is_deeply($x4->values, ["bd1bd1", undef, "bd2bd2"]);
t/functions.t:  # grep - case not ignore
t/functions.t:    my $x3 = r->grep($x1, $x2);
t/functions.t:    is_deeply($x3->values, [1]);
t/functions.t:  # grep - case ignore
t/functions.t:    my $x3 = r->grep($x1, $x2, {'ignore.case' => TRUE});
t/functions.t:    is_deeply($x3->values, [1, 3]);
t/functions.t:  my $x1 = c("a-z");
t/functions.t:  my $x2 = c("A-Z");
t/functions.t:  my $x4 = r->chartr($x1, $x2, $x3);
t/functions.t:  is_deeply($x4->values, ["ABC", "DEF", undef]);
t/functions.t:  # charmatch - empty string
t/functions.t:    my $x1 = r->charmatch("", "");
t/functions.t:    is_deeply($x1->value, 1);
t/functions.t:  # charmatch - multiple match
t/functions.t:    my $x1 = r->charmatch("m",   c("mean", "median", "mode"));
t/functions.t:    is_deeply($x1->value, 0);
t/functions.t:  # charmatch - multiple match
t/functions.t:    my $x1 = r->charmatch("m",   c("mean", "median", "mode"));
t/functions.t:    is_deeply($x1->value, 0);
t/functions.t:  # charmatch - one match
t/functions.t:    my $x1 = r->charmatch("med",   c("mean", "median", "mode"));
t/functions.t:    is_deeply($x1->value, 2);
t/functions.t:  # charmatch - one match, multiple elements
t/functions.t:    my $x1 = r->charmatch(c("med", "mod"),   c("mean", "median", "mode"));
t/functions.t:    is_deeply($x1->values, [2, 3]);
t/functions.t:  my $x2 = r->Im($x1);
t/functions.t:  is_deeply($x2->values, [2, 3]);
t/functions.t:  my $x2 = r->Re($x1);
t/functions.t:  is_deeply($x2->values, [1, 2]);
t/functions.t:  my $x2 = r->Conj($x1);
t/functions.t:  is_deeply($x2->values, [{re => 1, im => -2}, {re => 2, im => -3}]);
t/functions.t:  is(sprintf('%.4f', $x1->value), 3.1416);
t/functions.t:    my $x1 = r->complex(1, 2);
t/functions.t:    is($x1->value->{re}, 1);
t/functions.t:    is($x1->value->{im}, 2);
t/functions.t:  # complex - array
t/functions.t:    my $x1 = r->complex(c(1, 2), c(3, 4));
t/functions.t:    is_deeply($x1->values, [{re => 1, im => 3}, {re => 2, im => 4}]);
t/functions.t:  # complex - array, some elements lack
t/functions.t:    my $x1 = r->complex(c(1, 2), c(3, 4, 5));
t/functions.t:    is_deeply($x1->values, [{re => 1, im => 3}, {re => 2, im => 4}, {re => 0, im => 5}]);
t/functions.t:  # complex - re and im option
t/functions.t:    my $x1 = r->complex({re => c(1, 2), im => c(3, 4)});
t/functions.t:    is_deeply($x1->values, [{re => 1, im => 3}, {re => 2, im => 4}]);
t/functions.t:  # complex - mod and arg option
t/functions.t:    my $x1 = r->complex({mod => 2, arg => pi});
t/functions.t:    is($x1->value->{re}, -2);
t/functions.t:    cmp_ok(abs($x1->value->{im}), '<', 1e-15);
t/functions.t:  # complex - mod and arg option, omit arg
t/functions.t:    my $x1 = r->complex({mod => 2});
t/functions.t:    is($x1->value->{re}, 2);
t/functions.t:    is(sprintf("%.5f", $x1->value->{im}), '0.00000');
t/functions.t:  # complex - mod and arg option, omit mod
t/functions.t:    my $x1 = r->complex({arg => pi});
t/functions.t:    is($x1->value->{re}, -1);
t/functions.t:    cmp_ok(abs($x1->value->{im}), '<', 1e-15);
t/functions.t:  # append - after option
t/functions.t:    my $v2 = r->append($v1, 1, {after => 3});
t/functions.t:    is_deeply($v2->values, [1, 2, 3, 1, 4, 5]);
t/functions.t:  # append - no after option
t/functions.t:    my $v2 = r->append($v1, 1);
t/functions.t:    is_deeply($v2->values, [1, 2, 3, 4, 5, 1]);
t/functions.t:  # append - vector
t/functions.t:    my $v2 = r->append($v1, c(6, 7));
t/functions.t:    is_deeply($v2->values, [1, 2, 3, 4, 5, 6, 7]);
t/functions.t:    my $v4 = r->replace($v1, $v2, $v3);
t/functions.t:    is_deeply($v4->values, [1, 12, 3, 4, 15, 6, 7, 8, 9, 20]);
t/functions.t:  # replace - single value
t/functions.t:    my $v4 = r->replace($v1, $v2, 11);
t/functions.t:    is_deeply($v4->values, [1, 11, 3, 4, 11, 6, 7, 8, 9, 11]);
t/functions.t:  # replace - few values
t/functions.t:    my $v4 = r->replace($v1, $v2, c(12, 15));
t/functions.t:    is_deeply($v4->values, [1, 12, 3, 4, 15, 6, 7, 8, 9, 12]);
t/functions.t:  # cumprod - numeric
t/functions.t:    my $v3 = r->is_element($v1, $v2);
t/functions.t:    is_deeply($v3->values, [1, 1, 1, 0]);
t/functions.t:  # cumprod - complex
t/functions.t:    my $v3 = r->is_element($v1, $v2);
t/functions.t:    is_deeply($v3->values, [1, 1, 1, 0])
t/functions.t:  # setequal - equal
t/functions.t:    my $v3 = r->setequal($v1, $v2);
t/functions.t:    is_deeply($v3->value, 1);
t/functions.t:  # setequal - not equal
t/functions.t:    my $v3 = r->setequal($v1, $v2);
t/functions.t:    is_deeply($v3->value, 0);
t/functions.t:  # setequal - not equal, element count is diffrent
t/functions.t:    my $v3 = r->setequal($v1, $v2);
t/functions.t:    is_deeply($v3->value, 0);
t/functions.t:  my $v3 = r->setdiff($v1, $v2);
t/functions.t:  is_deeply($v3->values, [1, 2]);
t/functions.t:  my $v3 = r->intersect($v1, $v2);
t/functions.t:  is_deeply($v3->values, [3, 4]);
t/functions.t:  my $v3 = r->union($v1, $v2);
t/functions.t:  is_deeply($v3->values, [1, 2, 3, 4, 5, 6]);
t/functions.t:  my $v2 = r->cummin($v1);
t/functions.t:  is_deeply($v2->values, [7, 3, 3, 1]);
t/functions.t:  my $v2 = r->cummax($v1);
t/functions.t:  is_deeply($v2->values, [1, 5, 5, 7]);
t/functions.t:  # cumprod - logical
t/functions.t:    my $v2 = r->cumprod($v1);
t/functions.t:    is_deeply($v2->values, [1, 1, 0]);
t/functions.t:  # cumprod - integer
t/functions.t:    my $v2 = r->cumprod($v1);
t/functions.t:    is_deeply($v2->values, [2, 6, 24]);
t/functions.t:  # cumprod - double
t/functions.t:    my $v2 = r->cumprod($v1);
t/functions.t:    is_deeply($v2->values, [2, 6, 24]);
t/functions.t:  # cumprod - complex
t/functions.t:    my $v2 = r->cumprod($v1);
t/functions.t:    cmp_ok($v2->values->[0]->{re}, '==', 0);
t/functions.t:    cmp_ok($v2->values->[0]->{im}, '==', 2);
t/functions.t:    cmp_ok($v2->values->[1]->{re}, '==', -6);
t/functions.t:    cmp_ok($v2->values->[1]->{im}, '==', 0);
t/functions.t:    cmp_ok($v2->values->[2]->{re}, '==', 0);
t/functions.t:    cmp_ok($v2->values->[2]->{im}, '==', -24);
t/functions.t:  # cumsum - logical
t/functions.t:    my $v2 = r->cumsum($v1);
t/functions.t:    is_deeply($v2->values, [1, 1, 2]);
t/functions.t:  # cumsum - integer
t/functions.t:    my $v2 = r->cumsum($v1);
t/functions.t:    is_deeply($v2->values, [1, 3, 6]);
t/functions.t:  # cumsum - double
t/functions.t:    my $v2 = r->cumsum($v1);
t/functions.t:    is_deeply($v2->values, [1, 3, 6]);
t/functions.t:  # cumsum - complex
t/functions.t:    my $v2 = r->cumsum($v1);
t/functions.t:    is_deeply($v2->values, [{re => 0, im => 1}, {re => 0, im => 3}, {re => 0, im => 6}]);
t/functions.t:  my $v2 = r->rank($v1);
t/functions.t:  is_deeply($v2->values, [1, 5, 5, 5, 2.5, 2.5, 7]);
t/functions.t:  # order - 2 condition,decreasing TRUE
t/functions.t:    my $v3 = r->order($v1, $v2, {decreasing => TRUE});
t/functions.t:    is_deeply($v3->values, [6, 1, 3, 2, 4, 5]);
t/functions.t:  # order - 2 condition,decreasing FALSE
t/functions.t:    my $v3 = r->order($v1, $v2);
t/functions.t:    is_deeply($v3->values, [5, 4, 2, 3, 1, 6]);
t/functions.t:  # order - decreasing FALSE
t/functions.t:    my $v2 = r->order($v1, {decreasing => FALSE});
t/functions.t:    is_deeply($v2->values, [4, 1, 3, 2]);
t/functions.t:  # order - decreasing TRUE
t/functions.t:    my $v2 = r->order($v1, {decreasing => TRUE});
t/functions.t:    is_deeply($v2->values, [2, 3, 1, 4]);
t/functions.t:  # order - decreasing FALSE
t/functions.t:    my $v2 = r->order($v1);
t/functions.t:    is_deeply($v2->values, [4, 1, 3, 2]);
t/functions.t:  # diff - numeric
t/functions.t:    my $v2 = r->diff($v1);
t/functions.t:    is_deeply($v2->values, [4, 5, undef]);
t/functions.t:  # diff - complex
t/functions.t:    my $v2 = r->diff($v1);
t/functions.t:    is_deeply($v2->values, [{re => 4, im => 1}, undef]);
t/functions.t:    my $v1 = r->paste('x', se('1:3'));
t/functions.t:    is_deeply($v1->values, ['x 1', 'x 2', 'x 3']);
t/functions.t:    my $v1 = r->paste('x', se('1:3'), {sep => ''});
t/functions.t:    is_deeply($v1->values, ['x1', 'x2', 'x3']);
t/functions.t:  my $v2 = r->nchar($v1);
t/functions.t:  is_deeply($v2->values, [3, 2, undef])
t/functions.t:  my $v2 = r->tolower($v1);
t/functions.t:  is_deeply($v2->values, ["aa", "bb", undef])
t/functions.t:  my $v2 = r->toupper($v1);
t/functions.t:  is_deeply($v2->values, ["AA", "BB", undef])
t/functions.t:  my $v3 = r->match($v1, $v2);
t/functions.t:  is_deeply($v3->values, [undef, 2, 3, undef])
t/functions.t:  my $v2 = r->range($v1);
t/functions.t:  is_deeply($v2->values, [1, 3]);
t/functions.t:  my $pmax = r->pmax($v1, $v2);
t/functions.t:  is_deeply($pmax->values, [5, 6, 7, 8]);
t/functions.t:  my $pmin = r->pmin($v1, $v2);
t/functions.t:  is_deeply($pmin->values, [1, 2, 3, 4]);
t/functions.t:  my $v2 = r->rev($v1);
t/functions.t:  is_deeply($v2->values, [1, 3, 4, 2]);
t/functions.t:  is_deeply($v1->values, [1, 0]);
t/functions.t:  # sqrt - numeric
t/functions.t:    my $e2 = r->sqrt($e1);
t/functions.t:    is_deeply($e2->values, [2, 3]);
t/functions.t:  # sqrt - complex, 1 + 0i
t/functions.t:    my $e2 = r->sqrt($e1);
t/functions.t:    is_deeply($e2->value, {re => 1, im => 0});
t/functions.t:  # sqrt - complex, 4 + 0i
t/functions.t:    my $e2 = r->sqrt($e1);
t/functions.t:    is_deeply($e2->value, {re => 2, im => 0});
t/functions.t:  # sqrt - complex, -1 + 0i
t/functions.t:    my $e1 = c(-1 + 0*i);
t/functions.t:    my $e2 = r->sqrt($e1);
t/functions.t:    is_deeply($e2->value, {re => 0, im => 1});
t/functions.t:  # sqrt - complex, -4 + 0i
t/functions.t:    my $e1 = c(-4 + 0*i);
t/functions.t:    my $e2 = r->sqrt($e1);
t/functions.t:    is_deeply($e2->value, {re => 0, im => 2});
t/functions.t:    my $v2 = r->min($v1);
t/functions.t:    is_deeply($v2->values, [1]);
t/functions.t:  # min - multiple arrays
t/functions.t:    my $v3 = r->min($v1, $v2);
t/functions.t:    is_deeply($v3->values, [1]);
t/functions.t:  # min - no argument
t/functions.t:    my $v1 = r->min(NULL);
t/functions.t:    is_deeply($v1->values, ['Inf']);
t/functions.t:  # min - contain NA
t/functions.t:    my $v1 = r->min(c(1, 2, NaN, NA));
t/functions.t:    is_deeply($v1->values, [undef]);
t/functions.t:  # min - contain NaN
t/functions.t:    my $v1 = r->min(c(1, 2, NaN));
t/functions.t:    is_deeply($v1->values, ['NaN']);
t/functions.t:    my $v2 = r->max($v1);
t/functions.t:    is_deeply($v2->values, [3]);
t/functions.t:  # max - multiple arrays
t/functions.t:    my $v3 = r->max($v1, $v2);
t/functions.t:    is_deeply($v3->values, [6]);
t/functions.t:  # max - no argument
t/functions.t:    my $v1 = r->max(NULL);
t/functions.t:    is_deeply($v1->values, ['-Inf']);
t/functions.t:  # max - contain NA
t/functions.t:    my $v1 = r->max(c(1, 2, NaN, NA));
t/functions.t:    is_deeply($v1->values, [undef]);
t/functions.t:  # max - contain NaN
t/functions.t:    my $v1 = r->max(c(1, 2, NaN));
t/functions.t:    is_deeply($v1->values, ['NaN']);
t/functions.t:  # median - odd number
t/functions.t:    my $v2 = r->median($v1);
t/functions.t:    is_deeply($v2->values, [3]);
t/functions.t:  # median - even number
t/functions.t:    my $v2 = r->median($v1);
t/functions.t:    is_deeply($v2->values, [3.5]);
t/functions.t:  # quantile - odd number
t/functions.t:    my $v2 = r->quantile($v1);
t/functions.t:    is_deeply($v2->values, [0, 25, 50, 75, 100]);
t/functions.t:    is_deeply($v2->names->values, [qw/0%  25%  50%  75% 100% /]);
t/functions.t:  # quantile - even number
t/functions.t:    my $v2 = r->quantile($v1);
t/functions.t:    is_deeply($v2->values, [1.00, 25.75, 50.50, 75.25, 100.00]);
t/functions.t:  # quantile - one element
t/functions.t:    my $v2 = r->quantile($v1);
t/functions.t:    is_deeply($v2->values, [1, 1, 1, 1, 1]);
t/functions.t:  # uniqeu - numeric
t/functions.t:  my $v2 = r->unique($v1);
t/functions.t:  is_deeply($v2->values, [1, 2, 3, undef, 'Inf']);
t/functions.t:  my $na_value = $na->value;
t/functions.t:  # round - array reference
t/functions.t:    my $x1 = c(-1.3, 2.4, 2.5, 2.51, 3.51);
t/functions.t:    my $x2 = r->round($x1);
t/functions.t:      $x2->values,
t/functions.t:      [-1, 2, 2, 3, 4]
t/functions.t:  # round - matrix
t/functions.t:    my $x1 = c(-1.3, 2.4, 2.5, 2.51, 3.51);
t/functions.t:    my $x2 = r->round(matrix($x1));
t/functions.t:      $x2->values,
t/functions.t:      [-1, 2, 2, 3, 4]
t/functions.t:  # round - array reference
t/functions.t:    my $x1 = c(-13, 24, 25, 25.1, 35.1);
t/functions.t:    my $x2 = r->round($x1, -1);
t/functions.t:      $x2->values,
t/functions.t:      [-10, 20, 20, 30, 40]
t/functions.t:  # round - array reference
t/functions.t:    my $x1 = c(-13, 24, 25, 25.1, 35.1);
t/functions.t:    my $x2 = r->round($x1, {digits => -1});
t/functions.t:      $x2->values,
t/functions.t:      [-10, 20, 20, 30, 40]
t/functions.t:  # round - matrix
t/functions.t:    my $x1 = c(-13, 24, 25, 25.1, 35.1);
t/functions.t:    my $x2 = r->round(matrix($x1), -1);
t/functions.t:      $x2->values,
t/functions.t:      [-10, 20, 20, 30, 40]
t/functions.t:  # round - array reference
t/functions.t:    my $x1 = c(-0.13, 0.24, 0.25, 0.251, 0.351);
t/functions.t:    my $x2 = r->round($x1, 1);
t/functions.t:      $x2->values,
t/functions.t:      [-0.1, 0.2, 0.2, 0.3, 0.4]
t/functions.t:  # round - matrix
t/functions.t:    my $x1 = c(-0.13, 0.24, 0.25, 0.251, 0.351);
t/functions.t:    my $x2 = r->round(matrix($x1), 1);
t/functions.t:      $x2->values,
t/functions.t:      [-0.1, 0.2, 0.2, 0.3, 0.4]
t/functions.t:  # trunc - array reference
t/functions.t:    my $x1 = c(-1.2, -1, 1, 1.2);
t/functions.t:    my $x2 = r->trunc($x1);
t/functions.t:      $x2->values,
t/functions.t:      [-1, -1, 1, 1]
t/functions.t:  # trunc - matrix
t/functions.t:    my $x1 = c(-1.2, -1, 1, 1.2);
t/functions.t:    my $x2 = r->trunc(matrix($x1));
t/functions.t:      $x2->values,
t/functions.t:      [-1, -1, 1, 1]
t/functions.t:  # floor - array reference
t/functions.t:    my $x1 = c(2.5, 2.0, -1.0, -1.3);
t/functions.t:    my $x2 = r->floor($x1);
t/functions.t:      $x2->values,
t/functions.t:      [2, 2, -1, -2]
t/functions.t:  # floor - matrix
t/functions.t:    my $x1 = c(2.5, 2.0, -1.0, -1.3);
t/functions.t:    my $x2 = r->floor(matrix($x1));
t/functions.t:      $x2->values,
t/functions.t:      [2, 2, -1, -2]
t/functions.t:  # ceiling - array reference
t/functions.t:    my $x1 = c(2.5, 2.0, -1.0, -1.3);
t/functions.t:    my $x2 = r->ceiling($x1);
t/functions.t:      $x2->values,
t/functions.t:      [3, 2, -1, -1]
t/functions.t:  # ceiling - matrix
t/functions.t:    my $x1 = c(2.5, 2.0, -1.0, -1.3);
t/functions.t:    my $x2 = r->ceiling(matrix($x1));
t/functions.t:      $x2->values,
t/functions.t:      [3, 2, -1, -1]
t/functions.t:  # sqrt - array reference
t/functions.t:    my $x2 = r->sqrt($x1);
t/functions.t:      $x2->values,
t/functions.t:        sqrt $x1->values->[0],
t/functions.t:        sqrt $x1->values->[1],
t/functions.t:        sqrt $x1->values->[2]
t/functions.t:  # sqrt - matrix
t/functions.t:    my $x2 = r->sqrt(matrix($x1));
t/functions.t:      $x2->values,
t/functions.t:        sqrt $x1->values->[0],
t/functions.t:        sqrt $x1->values->[1],
t/functions.t:        sqrt $x1->values->[2]
t/functions.t:  # abs - array refference
t/functions.t:    my $x1 = r->abs(c(-3, 4));
t/functions.t:    is_deeply($x1->values, [3, 4]);
t/functions.t:  # abs - matrix
t/functions.t:    my $x1 = r->abs(matrix(c(-3, 4)));
t/functions.t:    is_deeply($x1->values, [3, 4]);
t/functions.t:  # abs - complex
t/functions.t:    my $x2 = r->abs($x1);
t/functions.t:    is_deeply($x2->values, [5, 10]);
t/functions.t:  # Mod - complex
t/functions.t:    my $x2 = r->Mod($x1);
t/functions.t:    is_deeply($x2->values, [5, 10]);
t/import.t:  is_deeply($v1->values, [1, 2, 3]);
t/import.t:  is_deeply($v1->values, [1, 2, 3]);
t/import.t:  is_deeply($x1->values, [1 .. 12]);
t/import.t:  is_deeply(r->dim($x1)->values, [4, 3]);
t/import.t:  is_deeply($m1->values, [1 .. 12]);
t/import.t:  is_deeply(r->dim($m1)->values, [4, 3]);
t/import.t:  is_deeply($v1->values, [{re => 0, im => 1}]);
t/import.t:  is_deeply($true->values, [1]);
t/import.t:  is_deeply($false->values, [0]);
t/import.t:  is_deeply($na->values, [undef]);
t/import.t:  is_deeply($nan->values, ['NaN']);
t/import.t:  is_deeply($inf->values, ['Inf']);
t/import.t:  is_deeply($null->values, []);
t/import.t:  is_deeply($null->dim->values, []);
t/import.t:  is_deeply($null->type, 'logical');
t/import.t:  my $v1 = r->c(1, 2, 3);
t/import.t:  is_deeply($v1->values, [1, 2, 3]);
t/list.t:  # list - get, multiple, names
t/list.t:    r->names($x1, c("n1", "n2", "n3"));
t/list.t:    my $l2 = $x1->get(c("n1", "n3"));
t/list.t:    ok(r->is_list($l2));
t/list.t:    is_deeply($l2->getin(1)->values, [1]);
t/list.t:    is_deeply($l2->getin(2)->values, [3]);
t/list.t:  # list - get
t/list.t:    my $l2 = $x1->get(1);
t/list.t:    ok(r->is_list($l2));
t/list.t:    is_deeply($l2->getin(1)->values, [1]);
t/list.t:  # list - as_list, input is array
t/list.t:    my $x2 = r->as_list($x1);
t/list.t:    ok(r->is_list($x2));
t/list.t:    is_deeply($x2->getin(1)->values, ["a", "b"]);
t/list.t:  # list - basic
t/list.t:    is_deeply($x1->list->[0]->values, [1, 2, 3]);
t/list.t:    is_deeply($x1->list->[1]->list->[0]->values, ["Hello"]);
t/list.t:      $x1->list->[1]->list->[1]->values,
t/list.t:  # list - argument is not array
t/list.t:    is_deeply($x1->list->[0]->values, [1]);
t/list.t:    is_deeply($x1->list->[1]->values, [2]);
t/list.t:    is_deeply($x1->list->[2]->values, [3]);
t/list.t:  # list - to_string
t/list.t:    my $str = $x1->to_string;
t/list.t:  # list - length
t/list.t:    is_deeply(r->length($x1)->values, [2]);
t/list.t:  # list - as_list, input is list
t/list.t:    my $l2 = r->as_list($x1);
t/list.t:  # list - getin
t/list.t:    my $x2 = $x1->getin(1);
t/list.t:    is_deeply($x2->values, ["a"]);
t/list.t:    my $x3 = $x1->getin(3)->getin(2);
t/list.t:    is_deeply($x3->values, ["d"]);
t/list.t:    my $x4 = $x1->getin(3)->getin(3)->getin(1);
t/list.t:    is_deeply($x4->values, ["e"]);
t/list.t:  # list - getin,name
t/list.t:    r->names($x1, c("n1", "n2", "n3"));
t/list.t:    my $x2 = $x1->getin("n1");
t/list.t:    is_deeply($x2->values, ["a"]);
t/list.t:    my $x3 = $x1->getin("n3")->getin(3)->getin(1);
t/list.t:    is_deeply($x3->values, ["e"]);
t/list.t:  # list - get, multiple
t/list.t:    my $l2 = $x1->get(c(1, 3));
t/list.t:    ok(r->is_list($l2));
t/list.t:    is_deeply($l2->getin(1)->values, [1]);
t/list.t:    is_deeply($l2->getin(2)->values, [3]);
t/list.t:  my $x2 = r->typeof($x1);
t/list.t:  ok(r->is_character($x2));
t/list.t:  is_deeply($x2->values, ['list']);
t/list.t:  my $x2 = r->ncol($x1);
t/list.t:  ok(r->is_null($x2));
t/list.t:  my $x2 = r->nrow($x1);
t/list.t:  ok(r->is_null($x2));
t/list.t:  # set - NULL, dimnames
t/list.t:    $x1->dimnames(list(c("r1", "r2", "r3"), c("c1", "c2", "c3")));
t/list.t:    $x1->at(2)->set(NULL);
t/list.t:    is_deeply($x1->getin(1)->values, [1, 2, 3]);
t/list.t:    is_deeply($x1->getin(2)->values, [7, 8, 9]);
t/list.t:    is_deeply($x1->dimnames->getin(1)->values, ["r1", "r2", "r3"]);
t/list.t:    is_deeply($x1->dimnames->getin(2)->values, ["c1", "c3"]);
t/list.t:  # set - NULL, names
t/list.t:    $x1->names(c("c1", "c2", "c3"));
t/list.t:    $x1->at(2)->set(NULL);
t/list.t:    is_deeply($x1->getin(1)->values, [1, 2, 3]);
t/list.t:    is_deeply($x1->getin(2)->values, [7, 8, 9]);
t/list.t:    is_deeply($x1->names->values, ["c1", "c3"]);
t/list.t:  # set - basic
t/list.t:    $x1->at(2)->set(5);
t/list.t:    is_deeply($x1->getin(1)->values, [1]);
t/list.t:    is_deeply($x1->getin(2)->values, [5]);
t/list.t:    is_deeply($x1->getin(3)->values, [3]);
t/list.t:  # set - name
t/list.t:    r->names($x1, c("n1", "n2", "n3"));
t/list.t:    $x1->at("n2")->set(5);
t/list.t:    is_deeply($x1->getin(1)->values, [1]);
t/list.t:    is_deeply($x1->getin(2)->values, [5]);
t/list.t:    is_deeply($x1->getin(3)->values, [3]);
t/list.t:  # set - two index
t/list.t:    $x1->getin(2)->at(2)->set(5);
t/list.t:    is_deeply($x1->getin(1)->values, [1]);
t/list.t:    is_deeply($x1->getin(2)->getin(1)->values, [2]);
t/list.t:    is_deeply($x1->getin(2)->getin(2)->values, [5]);
t/list.t:  # set - tree index
t/list.t:    $x1->getin(2)->getin(3)->at(1)->set(5);
t/list.t:    is_deeply($x1->getin(2)->getin(3)->getin(1)->values, [5]);
t/complex.t:my $r = Rstats::Class->new;
t/complex.t:  # comparison operator - ==, true
t/complex.t:    is($ret->value, 1);
t/complex.t:  # comparison operator - ==, false
t/complex.t:    is($ret->value, 0);
t/complex.t:  # comparison operator - !=, true
t/complex.t:    is(Rstats::VectorFunc::not_equal($z1, $z2)->value, 0);
t/complex.t:  # comparison operator - !=, false
t/complex.t:    is(Rstats::VectorFunc::not_equal($z1, $z2)->value, 1);
t/complex.t:  # comparison operator - <, error
t/complex.t:  # comparison operator - <=, error
t/complex.t:  # comparison operator - >, error
t/complex.t:  # comparison operator - >=, error
t/complex.t:  # to_string - basic
t/complex.t:  # to_string - image number is 0
t/complex.t:  # to_string - image number is minus
t/complex.t:    my $z1 = Rstats::VectorFunc::new_complex({re => 1, im => -1});
t/complex.t:    is("$z1", "1-1i");
t/complex.t:    is($z1->value->{re}, 1);
t/complex.t:    is($z1->value->{im}, 2);
t/complex.t:  # operation - negation
t/complex.t:    is($z2->value->{re}, -1);
t/complex.t:    is($z2->value->{im}, -2);
t/complex.t:  # operation - add
t/complex.t:    is($z3->value->{re}, 4);
t/complex.t:    is($z3->value->{im}, 6);
t/complex.t:  # operation - subtract
t/complex.t:    is($z3->value->{re}, -2);
t/complex.t:    is($z3->value->{im}, -2);
t/complex.t:  # operation - multiply
t/complex.t:    is($z3->value->{re}, -5);
t/complex.t:    is($z3->value->{im}, 10);
t/complex.t:  # operation - abs
t/complex.t:    is($abs->value, 5);
t/complex.t:  # operation - Conj
t/complex.t:    is($conj->value->{re}, 1);
t/complex.t:    is($conj->value->{im}, -2);
t/complex.t:  # operation - divide
t/complex.t:    my $z1 = Rstats::VectorFunc::new_complex({re => 5, im => -6});
t/complex.t:    is($z3->value->{re}, 3/13);
t/complex.t:    is($z3->value->{im}, -28/13);
t/complex.t:  # operation - pow
t/complex.t:    is($z3->value->{re}, -11);
t/complex.t:    is($z3->value->{im}, -2);
t/vector-function.t:  # sqrt - numeric
t/vector-function.t:    is($e2->value, 2);
t/vector-function.t:  # sqrt - complex
t/vector-function.t:    my $e1 = Rstats::VectorFunc::new_complex({re => -1, im => 0});
t/vector-function.t:    is_deeply($e2->value, {re => 0, im => 1});
t/read.t:  # read_table - character, complex, double, integer, logical, sep default(\s+)
t/read.t:    my $d1 = r->read_table("$FindBin::Bin/data/read.t/basic.txt");
t/read.t:    ok(r->is_factor($d1->getin(1)));
t/read.t:    is_deeply($d1->getin(1)->values, [qw/2 3 4 5 1/]);
t/read.t:    is_deeply(r->levels($d1->getin(1))->values, [qw/NA NB NC ND NE/]);
t/read.t:    ok(r->is_complex($d1->getin(2)));
t/read.t:    is_deeply($d1->getin(2)->values, [{re => 1, im => 1}, {re => 1, im => 2}, {re => 1, im => 3}, {re => 1, im => 4}, undef]);
t/read.t:    ok(r->is_double($d1->getin(3)));
t/read.t:    is_deeply($d1->getin(3)->values, [qw/1.1 1.2 1.3 1.4/, undef]);
t/read.t:    ok(r->is_integer($d1->getin(4)));
t/read.t:    is_deeply($d1->getin(4)->values, [qw/1 2 3 4/, undef]);
t/read.t:    ok(r->is_logical($d1->getin(5)));
t/read.t:    is_deeply($d1->getin(5)->values, [qw/1 0 1 0/, undef]);
t/read.t:    is_deeply($d1->names->values, [qw/V1 V2 V3 V4 V5/]);
t/read.t:  # read_table - header
t/read.t:    my $d1 = r->read_table("$FindBin::Bin/data/read.t/header.txt",{header => T});
t/read.t:    is_deeply($d1->names->values, [qw/a b/]);
t/read.t:    is_deeply($d1->getin(1)->values, [qw/1 2/]);
t/read.t:    is_deeply($d1->getin(2)->values, [qw/1.1 1.2/]);
t/read.t:  # read_table - sep comma
t/read.t:    my $d1 = r->read_table("$FindBin::Bin/data/read.t/comma.txt",{sep => ','});
t/read.t:    is_deeply($d1->getin(1)->values, [qw/1 2/]);
t/read.t:    is_deeply($d1->getin(2)->values, [qw/1.1 1.2/]);
t/read.t:  # read_table - skip
t/read.t:    my $d1 = r->read_table("$FindBin::Bin/data/read.t/skip.txt",{skip => 2});
t/read.t:    is_deeply($d1->getin(1)->values, [qw/2 3/]);
t/read.t:    is_deeply($d1->getin(2)->values, [qw/1.1 1.2/]);
t/vector-logical.t:  # logical - bool, TRUE
t/vector-logical.t:  # logical - bool, FALSE
t/vector-logical.t:    ok(!$false->value);
t/vector-logical.t:    ok($num->is_integer);
t/vector-logical.t:    is($num->value, -1);
t/vector-logical.t:    ok($num->is_integer);
t/vector-logical.t:    is($num->value, 0);
t/functions-trig.t:  # atanh - complex, 1 + 2i
t/functions-trig.t:    my $x2 = r->atanh($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '0.173287');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '1.178097');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # atanh - complex, 1 + 0i
t/functions-trig.t:    my $x2 = r->atanh($x1);
t/functions-trig.t:    is($x2->value->{re}, 'Inf');
t/functions-trig.t:    is($x2->value->{im}, 'NaN');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # atanh - complex, -1 + 0i
t/functions-trig.t:    my $x1 = c(-1 + 0*i);
t/functions-trig.t:    my $x2 = r->atanh($x1);
t/functions-trig.t:    is($x2->value->{re}, '-Inf');
t/functions-trig.t:    is($x2->value->{im}, 'NaN');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # atanh - double,array
t/functions-trig.t:    my $x1 = array(c(0, 0.5, 1, 2, -1, -0.5, -2));
t/functions-trig.t:    my $x2 = r->atanh($x1);
t/functions-trig.t:    is($x2->values->[0], 0);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[1]), '0.549306');
t/functions-trig.t:    is($x2->values->[2], 'Inf');
t/functions-trig.t:    is($x2->values->[3], 'NaN');
t/functions-trig.t:    is($x2->values->[4], '-Inf');
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[5]), '-0.549306');
t/functions-trig.t:    is($x2->values->[6], 'NaN');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [7]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # atanh - integer
t/functions-trig.t:    my $x1 = array(c(0, 1, 2, -1, -2));
t/functions-trig.t:    my $x2 = r->atanh($x1);
t/functions-trig.t:    is($x2->values->[0], 0);
t/functions-trig.t:    is($x2->values->[1], 'Inf');
t/functions-trig.t:    is($x2->values->[2], 'NaN');
t/functions-trig.t:    is($x2->values->[3], '-Inf');
t/functions-trig.t:    is($x2->values->[4], 'NaN');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [5]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # atanh - Inf
t/functions-trig.t:    my $x2 = r->atanh($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # atanh - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->atanh($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # atanh - NA
t/functions-trig.t:    my $x2 = r->atanh($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # atanh - NaN
t/functions-trig.t:    my $x2 = r->atanh($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # acosh - complex, -1 + 0i
t/functions-trig.t:    my $x1 = c(-1 + 0*i);
t/functions-trig.t:    my $x2 = r->acosh($x1);
t/functions-trig.t:    cmp_ok($x2->value->{re}, '==', 0);
t/functions-trig.t:    #is($x2->value->{re}, -0);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '3.141593');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # acosh - complex, -2 + 0i
t/functions-trig.t:    my $x1 = c(-2 + 0*i);
t/functions-trig.t:    my $x2 = r->acosh($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '1.316958');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '3.141593');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # acosh - complex, 0 + 1i
t/functions-trig.t:    my $x2 = r->acosh($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '0.881374');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '1.570796');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # acosh - complex, 1 + 1i
t/functions-trig.t:    my $x2 = r->acosh($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '1.061275');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '0.904557');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # acosh - complex, -1 + 1i
t/functions-trig.t:    my $x1 = c(-1 + 1*i);
t/functions-trig.t:    my $x2 = r->acosh($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '1.061275');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '2.237036');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # acosh - double,array
t/functions-trig.t:    my $x2 = r->acosh($x1);
t/functions-trig.t:    is($x2->values->[0], 'NaN');
t/functions-trig.t:    is($x2->values->[1], 0);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[2]), '1.316958');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [3]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # acosh - integer
t/functions-trig.t:    my $x1 = r->as_integer(array(c(0, 1, 2)));
t/functions-trig.t:    my $x2 = r->acosh($x1);
t/functions-trig.t:    is($x2->values->[0], 'NaN');
t/functions-trig.t:    is($x2->values->[1], 0);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[2]), '1.316958');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [3]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # acosh - Inf
t/functions-trig.t:    my $x2 = r->acosh($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # acosh - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->acosh($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # acosh - NA
t/functions-trig.t:    my $x2 = r->acosh($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # acosh - NaN
t/functions-trig.t:    my $x2 = r->acosh($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # asinh - complex, 1 + 2i
t/functions-trig.t:    my $x2 = r->asinh($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '1.469352');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '1.063440');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # asinh - double
t/functions-trig.t:    my $x2 = r->asinh($x1);
t/functions-trig.t:    is($x2->values->[0], '0');
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[1]), '0.881374');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [2]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # asinh - integer
t/functions-trig.t:    my $x1 = r->as_integer(array(c(0, 1)));
t/functions-trig.t:    my $x2 = r->asinh($x1);
t/functions-trig.t:    is($x2->values->[0], '0');
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[1]), '0.881374');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [2]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # asinh - Inf
t/functions-trig.t:    my $x2 = r->asinh($x1);
t/functions-trig.t:    is($x2->value, 'Inf');
t/functions-trig.t:  # asinh - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->asinh($x1);
t/functions-trig.t:    ok($x2->value, '-Inf');
t/functions-trig.t:  # asinh - NA
t/functions-trig.t:    my $x2 = r->asinh($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # asinh - NaN
t/functions-trig.t:    my $x2 = r->asinh($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # tanh - complex, 1 + 2i
t/functions-trig.t:    my $x2 = r->tanh($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '1.166736');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '-0.243458');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # tanh - complex, 1 + Inf
t/functions-trig.t:    my $x1 = r->complex({re => 1, im => Inf});
t/functions-trig.t:    my $x2 = r->tanh($x1);
t/functions-trig.t:    is($x2->value->{re}, 'NaN');
t/functions-trig.t:    is($x2->value->{im}, 'NaN');
t/functions-trig.t:  # tanh - complex, -Inf - 2i
t/functions-trig.t:    my $x1 = c(-Inf - 2*i);
t/functions-trig.t:    my $x2 = r->tanh($x1);
t/functions-trig.t:    is($x2->value->{re}, '-1');
t/functions-trig.t:    cmp_ok($x2->value->{im}, '==', 0);
t/functions-trig.t:  # tanh - complex, -Inf + 2i
t/functions-trig.t:    my $x1 = c(-Inf + 2*i);
t/functions-trig.t:    my $x2 = r->tanh($x1);
t/functions-trig.t:    is($x2->value->{re}, '-1');
t/functions-trig.t:    is($x2->value->{im}, '0');
t/functions-trig.t:  # tanh - double,array
t/functions-trig.t:    my $x2 = r->tanh($x1);
t/functions-trig.t:    is($x2->values->[0], '0');
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[1]), '0.964028');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [2]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # tanh - Inf
t/functions-trig.t:    my $x2 = r->tanh($x1);
t/functions-trig.t:    is($x2->value, '1');
t/functions-trig.t:  # tanh - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->tanh($x1);
t/functions-trig.t:    is($x2->value, '-1');
t/functions-trig.t:  # tanh - NA
t/functions-trig.t:    my $x2 = r->tanh($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # tanh - NaN
t/functions-trig.t:    my $x2 = r->tanh($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # cosh - complex, 1 + 2i
t/functions-trig.t:    my $x2 = r->cosh($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '-0.642148');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '1.068607');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # cosh - complex, -Inf - 2i
t/functions-trig.t:    my $x1 = c(-Inf - 2*i);
t/functions-trig.t:    my $x2 = r->cosh($x1);
t/functions-trig.t:    is($x2->value->{re}, '-Inf');
t/functions-trig.t:    is($x2->value->{im}, 'Inf');
t/functions-trig.t:  # cosh - complex, -Inf + 2i
t/functions-trig.t:    my $x1 = c(-Inf + 2*i);
t/functions-trig.t:    my $x2 = r->cosh($x1);
t/functions-trig.t:    is($x2->value->{re}, '-Inf');
t/functions-trig.t:    ok($x2->value->{im}, '-Inf');
t/functions-trig.t:  # cosh - double,array
t/functions-trig.t:    my $x1 = array(c(0, Inf, 2, -Inf));
t/functions-trig.t:    my $x2 = r->cosh($x1);
t/functions-trig.t:    is($x2->values->[0], '1');
t/functions-trig.t:    is($x2->values->[1], 'Inf');
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[2]), '3.762196');
t/functions-trig.t:    is($x2->values->[3], 'Inf');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [4]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # cosh - Inf
t/functions-trig.t:    my $x2 = r->cosh($x1);
t/functions-trig.t:    is($x2->value, 'Inf');
t/functions-trig.t:  # cosh - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->cosh($x1);
t/functions-trig.t:    is($x2->value, 'Inf');
t/functions-trig.t:  # cosh - NA
t/functions-trig.t:    my $x2 = r->cosh($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # cosh - NaN
t/functions-trig.t:    my $x2 = r->cosh($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # sinh - complex, 1 + 2i
t/functions-trig.t:    my $x2 = r->sinh($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '-0.489056');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '1.403119');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # sinh - complex, -Inf - 2i
t/functions-trig.t:    my $x1 = c(-Inf - 2*i);
t/functions-trig.t:    my $x2 = r->sinh($x1);
t/functions-trig.t:    is($x2->value->{re}, 'Inf');
t/functions-trig.t:    is($x2->value->{im}, '-Inf');
t/functions-trig.t:  # sinh - complex, -Inf + 2i
t/functions-trig.t:    my $x1 = c(-Inf + 2*i);
t/functions-trig.t:    my $x2 = r->sinh($x1);
t/functions-trig.t:    is($x2->value->{re}, 'Inf');
t/functions-trig.t:    is($x2->value->{im}, 'Inf');
t/functions-trig.t:  # sinh - double,array
t/functions-trig.t:    my $x1 = array(c(0, Inf, 2, -Inf));
t/functions-trig.t:    my $x2 = r->sinh($x1);
t/functions-trig.t:    is($x2->values->[0], '0');
t/functions-trig.t:    is($x2->values->[1], 'Inf');
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[2]), '3.626860');
t/functions-trig.t:    is($x2->values->[3], '-Inf');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [4]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # sinh - Inf
t/functions-trig.t:    my $x2 = r->sinh($x1);
t/functions-trig.t:    is($x2->value, 'Inf');
t/functions-trig.t:  # sinh - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->sinh($x1);
t/functions-trig.t:    is($x2->value, '-Inf');
t/functions-trig.t:  # sinh - NA
t/functions-trig.t:    my $x2 = r->sinh($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # sinh - NaN
t/functions-trig.t:    my $x2 = r->sinh($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # atan - complex, 0
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is($x2->values->[0]{re}, 0);
t/functions-trig.t:    is($x2->values->[0]{im}, 0);
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # atan - complex, 1i
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is($x2->values->[0]{re}, 0);
t/functions-trig.t:    is($x2->values->[0]->{im}, 'Inf');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # atan - complex, -1
t/functions-trig.t:    my $x1 = c(-1*i);
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is($x2->values->[0]{re}, 0);
t/functions-trig.t:    is($x2->values->[0]->{im}, '-Inf');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # atan - complex, 1 + 2i
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '1.338973');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '0.402359');
t/functions-trig.t:  # atan - double,array
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]), '0.463648');
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[1]), '0.540420');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [2]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # atan - Inf
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value), '1.570796');
t/functions-trig.t:  # atan - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value), '-1.570796');
t/functions-trig.t:  # atan - NA
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # atan - NaN
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # acos - complex, -1 - 1*i
t/functions-trig.t:    my $x1 = c(-1 - 1*i);
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '2.237036');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '1.061275');
t/functions-trig.t:  # acos - complex, 1 + 2*i
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '1.143718');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '-1.528571');
t/functions-trig.t:  # acos - complex, 0.5 + 0.5*i
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '1.118518');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '-0.530638');
t/functions-trig.t:  # acos - complex, 1 + 1*i
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '0.904557');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '-1.061275');
t/functions-trig.t:  # acos - complex, 1.5 + 1.5*i
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '0.840395');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '-1.449734');
t/functions-trig.t:  # acos - complex, -0.5 - 0.5*i
t/functions-trig.t:    my $x1 = c(-0.5 - 0.5*i);
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '2.023075');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '0.530638');
t/functions-trig.t:  # acos - complex, 0
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]{re}), 1.570796);
t/functions-trig.t:    is($x2->values->[0]{im}, 0);
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # acos - complex, 1
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is($x2->values->[0]{re}, 0);
t/functions-trig.t:    is($x2->values->[0]{im}, 0);
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # acos - complex, -1.5
t/functions-trig.t:    my $x1 = c(-1.5 + 0*i);
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]{re}), '3.141593');
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]{im}), '-0.962424');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # acos - double,array
t/functions-trig.t:    my $x1 = array(c(1, 1.1, -1.1));
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is($x2->values->[0], 0);
t/functions-trig.t:    is($x2->values->[1], 'NaN');
t/functions-trig.t:    is($x2->values->[2], 'NaN');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [3]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # acos - Inf
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # acos - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # acos - NA
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # acos - NaN
t/functions-trig.t:    my $x2 = r->acos($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # asin - complex, 1 + 2*i
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '0.427079');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '1.528571');
t/functions-trig.t:  # asin - complex, 0.5 + 0.5*i
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '0.452278');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '0.530638');
t/functions-trig.t:  # asin - complex, 1 + 1*i
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '0.666239');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '1.061275');
t/functions-trig.t:  # asin - complex, 1.5 + 1.5*i
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '0.730401');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '1.449734');
t/functions-trig.t:  # asin - complex, -0.5 - 0.5*i
t/functions-trig.t:    my $x1 = c(-0.5 - 0.5*i);
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '-0.452278');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '-0.530638');
t/functions-trig.t:  # asin - complex, -1 - 1*i
t/functions-trig.t:    my $x1 = c(-1 - 1*i);
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), '-0.666239');
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), '-1.061275');
t/functions-trig.t:  # asin - complex, 0
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is($x2->values->[0]{re}, 0);
t/functions-trig.t:    is($x2->values->[0]{im}, 0);
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # asin - complex, 0.5,
t/functions-trig.t:    my $x1 = c(-1.5 + 0*i);
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]{re}), '-1.570796');
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]{im}), '0.962424');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # asin - double,array
t/functions-trig.t:    my $x1 = array(c(1, 1.1, -1.1));
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]), '1.570796');
t/functions-trig.t:    is($x2->values->[1], 'NaN');
t/functions-trig.t:    is($x2->values->[2], 'NaN');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [3]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # asin - Inf
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # asin - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # asin - NA
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # asin - NaN
t/functions-trig.t:    my $x2 = r->asin($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # atan - complex
t/functions-trig.t:    my $x1 = c(1 + 2*i, i, -i);
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]{re}), '1.338973');
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]{im}), '0.402359');
t/functions-trig.t:    is($x2->values->[1]{re}, 0);
t/functions-trig.t:    is($x2->values->[1]{im}, 'Inf');
t/functions-trig.t:    is($x2->values->[2]{re}, 0);
t/functions-trig.t:    is($x2->values->[2]{im}, '-Inf');
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # atan - double,array
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]), '0.785398');
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[1]), '1.107149');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [2]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # atan - Inf
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]), '1.570796');
t/functions-trig.t:  # atan - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is(sprintf("%.6f", $x2->values->[0]), '-1.570796');
t/functions-trig.t:  # atan - NA
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # atan - NaN
t/functions-trig.t:    my $x2 = r->atan($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # atan2 - complex
t/functions-trig.t:    my $x3 = r->atan2($x1, $x2);
t/functions-trig.t:    is(sprintf("%.6f", $x3->value->{re}), 0.416491);
t/functions-trig.t:    is(sprintf("%.6f", $x3->value->{im}), 0.067066);
t/functions-trig.t:    ok(r->is_complex($x3));
t/functions-trig.t:  # atan2 - double,array
t/functions-trig.t:    my $x3 = r->atan2($x1, $x2);
t/functions-trig.t:    is(sprintf("%.6f", $x3->values->[0]), '0.321751');
t/functions-trig.t:    is(sprintf("%.6f", $x3->values->[1]), '0.463648');
t/functions-trig.t:    is_deeply(r->dim($x3)->values, [2]);
t/functions-trig.t:    ok(r->is_double($x3));
t/functions-trig.t:  # atan2 - y is -Inf, x is Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x3 = r->atan2($x1, $x2);
t/functions-trig.t:    is(sprintf("%.6f", $x3->value), '-0.785398');
t/functions-trig.t:  # atan2 - y is inf, x is -inf
t/functions-trig.t:    my $x2 = c(-Inf);
t/functions-trig.t:    my $x3 = r->atan2($x1, $x2);
t/functions-trig.t:    is(sprintf("%.6f", $x3->value), '2.356194');
t/functions-trig.t:  # atan2 - x and y is Inf
t/functions-trig.t:    my $x3 = r->atan2($x1, $x2);
t/functions-trig.t:    is(sprintf("%.6f", $x3->value), '0.785398');
t/functions-trig.t:  # atan2 - x and y is -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = c(-Inf);
t/functions-trig.t:    my $x3 = r->atan2($x1, $x2);
t/functions-trig.t:    is(sprintf("%.6f", $x3->value), '-2.356194');
t/functions-trig.t:  # atan2 - x is Inf
t/functions-trig.t:    my $x3 = r->atan2($x1, $x2);
t/functions-trig.t:    is($x3->value, 0);
t/functions-trig.t:  # atan2 - y >= 0, x is -Inf
t/functions-trig.t:    my $x2 = c(-Inf, -Inf);
t/functions-trig.t:    my $x3 = r->atan2($x1, $x2);
t/functions-trig.t:    is(sprintf("%.6f", $x3->values->[0]), 3.141593);
t/functions-trig.t:    is(sprintf("%.6f", $x3->values->[1]), 3.141593);
t/functions-trig.t:  # atan2 - y >= 0, x is -Inf
t/functions-trig.t:    my $x1 = c(-1);
t/functions-trig.t:    my $x2 = c(-Inf);
t/functions-trig.t:    my $x3 = r->atan2($x1, $x2);
t/functions-trig.t:    is(sprintf("%.6f", $x3->value), -3.141593);
t/functions-trig.t:  # atan2 - y is Inf
t/functions-trig.t:    my $x3 = r->atan2($x1, $x2);
t/functions-trig.t:    is(sprintf("%.6f", $x3->value), '1.570796');
t/functions-trig.t:  # atan2 - y is -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x3 = r->atan2($x1, $x2);
t/functions-trig.t:    is(sprintf("%.6f", $x3->value), '-1.570796');
t/functions-trig.t:  # atan2 - y is NA
t/functions-trig.t:    my $x1 = r->atan2(NA, 0);
t/functions-trig.t:    ok(!defined $x1->value);
t/functions-trig.t:  # atan2 - x is NA
t/functions-trig.t:    my $x1 = r->atan2(0, NA);
t/functions-trig.t:    ok(!defined $x1->value);
t/functions-trig.t:  # atan2 - y is NaN
t/functions-trig.t:    my $x1 = r->atan2(NaN, 0);
t/functions-trig.t:    is($x1->value, 'NaN');
t/functions-trig.t:  # atan2 - x is NaN
t/functions-trig.t:    my $x1 = r->atan2(0, NaN);
t/functions-trig.t:    is($x1->value, 'NaN');
t/functions-trig.t:  # tan - complex
t/functions-trig.t:    my $x2 = r->tan($x1);
t/functions-trig.t:    my $exp = Math::Complex->make(1, 2)->tan;
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{re}), 0.033813);
t/functions-trig.t:    is(sprintf("%.6f", $x2->value->{im}), 1.014794);
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # tan - double, array
t/functions-trig.t:    my $x2 = r->tan($x1);
t/functions-trig.t:      $x2->values,
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [2]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # cos - complex
t/functions-trig.t:    my $x2 = r->cos($x1);
t/functions-trig.t:    my $exp = Math::Complex->make(1, 2)->cos;
t/functions-trig.t:    is($x2->value->{re}, $exp_re);
t/functions-trig.t:    is($x2->value->{im}, $exp_im);
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # cos - double,array
t/functions-trig.t:    my $x2 = r->cos($x1);
t/functions-trig.t:    cmp_ok(abs($x2->values->[0]), '<', 1e-15);
t/functions-trig.t:    is(sprintf("%.5f", $x2->values->[1]), '0.50000');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [2]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # cos - Inf
t/functions-trig.t:    my $x2 = r->cos($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # cos - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->cos($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # cos - NA
t/functions-trig.t:    my $x2 = r->cos($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # cos - NaN
t/functions-trig.t:    my $x2 = r->cos($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # sin - complex
t/functions-trig.t:    my $x2 = r->sin($x1);
t/functions-trig.t:    my $exp = Math::Complex->make(1, 2)->sin;
t/functions-trig.t:    is($x2->value->{re}, $exp_re);
t/functions-trig.t:    is($x2->value->{im}, $exp_im);
t/functions-trig.t:    ok(r->is_complex($x2));
t/functions-trig.t:  # sin - double,array
t/functions-trig.t:    my $x2 = r->sin($x1);
t/functions-trig.t:    is(sprintf("%.5f", $x2->values->[0]), '1.00000');
t/functions-trig.t:    is(sprintf("%.5f", $x2->values->[1]), '0.50000');
t/functions-trig.t:    is_deeply(r->dim($x2)->values, [2]);
t/functions-trig.t:    ok(r->is_double($x2));
t/functions-trig.t:  # sin - Inf
t/functions-trig.t:    my $x2 = r->sin($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # sin - -Inf
t/functions-trig.t:    my $x1 = c(-Inf);
t/functions-trig.t:    my $x2 = r->sin($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/functions-trig.t:  # sin - NA
t/functions-trig.t:    my $x2 = r->sin($x1);
t/functions-trig.t:    ok(!defined $x2->value);
t/functions-trig.t:  # sin - NaN
t/functions-trig.t:    my $x2 = r->sin($x1);
t/functions-trig.t:    is($x2->value, 'NaN');
t/vector.t:  # names - get
t/vector.t:    r->names($v1 => c('a', 'b', 'c', 'd'));
t/vector.t:    my $v2 = $v1->get(c('b', 'd'));
t/vector.t:    is_deeply($v2->values, [2, 4]);
t/vector.t:  # names - to_string
t/vector.t:    r->names($v => c('a', 'b', 'c'));
t/vector.t:  # inner product - inner product
t/vector.t:    is_deeply($v3->values, [32]);
t/vector.t:    is_deeply(r->dim($v3)->values, [1, 1]);
t/vector.t:  # innert product - size is different
t/vector.t:    like($@, qr/non-conformable/);
t/vector.t:  # innert product - size of first argument is zero
t/vector.t:  # innert product - size of second argument is zero
t/basic.t:    is_deeply($v->values, ["a", "b"]);
t/basic.t:    is(r->typeof($v)->value, 'double');
t/basic.t:    is_deeply($v->values, [1, 2, 3]);
t/basic.t:    is_deeply($v->values, [1, 2, 3]);
t/basic.t:    is_deeply($v->values, [1, 2, 3, 4, 5]);
t/basic.t:    is_deeply($v->values, [1, 2, 3]);
t/basic.t:    is_deeply($v->values, [1, 1.5, 2, 2.5, 3]);
t/basic.t:  my $v1 = r->NULL;
t/basic.t:  is_deeply($v1->values, []);
t/basic.t:  $v1->at(3)->set(5);
t/basic.t:  is_deeply($v1->values, [undef, undef, 5]);
t/basic.t:    my $tail = r->tail($v1);
t/basic.t:    is_deeply($tail->values, [2, 3, 4, 5, 6, 7]);
t/basic.t:  # tail - values is low than 6
t/basic.t:    my $tail = r->tail($v1);
t/basic.t:    is_deeply($tail->values, [1, 2, 3]);
t/basic.t:  # tail - n option
t/basic.t:    my $tail = r->tail($v1, {n => 3});
t/basic.t:    is_deeply($tail->values, [2, 3, 4]);
t/basic.t:  # class - vector, numeric
t/basic.t:    is_deeply($x1->class->values, ['numeric']);
t/basic.t:  # class - matrix
t/basic.t:    is_deeply($x1->class->values, ['matrix']);
t/basic.t:  # class - array
t/basic.t:    is_deeply($x1->class->values, ['array']);
t/basic.t:  # class - factor
t/basic.t:    is_deeply($x1->class->values, ['factor']);
t/basic.t:  # class - factor, ordered
t/basic.t:    is_deeply($x1->class->values, ['factor', 'ordered']);
t/basic.t:  # class - list
t/basic.t:    is_deeply($x1->class->values, ['list']);
t/basic.t:  # class - data frame
t/basic.t:    is_deeply($x1->class->values, ['data.frame']);
t/basic.t:  # as_numeric - from complex
t/basic.t:    my $x1 = c(r->complex(1, 1), r->complex(2, 2));
t/basic.t:    r->mode($x1 => 'complex');
t/basic.t:    my $x2 = r->as_numeric($x1);
t/basic.t:    is(r->mode($x2)->value, 'numeric');
t/basic.t:    is_deeply($x2->values, [1, 2]);
t/basic.t:  # as_numeric - from numeric
t/basic.t:    r->mode($x1 => 'numeric');
t/basic.t:    my $x2 = r->as_numeric($x1);
t/basic.t:    is(r->mode($x2)->value, 'numeric');
t/basic.t:    is_deeply($x2->values, [0.1, 1.1, 2.2]);
t/basic.t:  # as_numeric - from integer
t/basic.t:    r->mode($x1 => 'integer');
t/basic.t:    my $x2 = r->as_numeric($x1);
t/basic.t:    is(r->mode($x2)->value, 'numeric');
t/basic.t:    is_deeply($x2->values, [0, 1, 2]);
t/basic.t:  # as_numeric - from logical
t/basic.t:    my $x1 = c(r->TRUE, r->FALSE);
t/basic.t:    r->mode($x1 => 'logical');
t/basic.t:    my $x2 = r->as_numeric($x1);
t/basic.t:    is(r->mode($x2)->value, 'numeric');
t/basic.t:    is_deeply($x2->values, [1, 0]);
t/basic.t:  # as_numeric - from character
t/basic.t:    my $x1 = r->as_integer(c(0, 1, 2));
t/basic.t:    my $x2 = r->as_numeric($x1);
t/basic.t:    is(r->mode($x2)->value, 'numeric');
t/basic.t:    is_deeply($x2->values, [0, 1, 2]);
t/basic.t:  # is_*, as_*, typeof - integer
t/basic.t:    ok(r->is_integer(r->as_integer($c)));
t/basic.t:    is(r->mode(r->as_integer($c))->value, 'numeric');
t/basic.t:    is(r->typeof(r->as_integer($c))->value, 'integer');
t/basic.t:  # is_*, as_*, typeof - character
t/basic.t:    ok(r->is_character(r->as_character($c)));
t/basic.t:    is(r->mode(r->as_character($c))->value, 'character');
t/basic.t:    is(r->typeof(r->as_character($c))->value, 'character');
t/basic.t:  # is_*, as_*, typeof - complex
t/basic.t:    ok(r->is_complex(r->as_complex($c)));
t/basic.t:    is(r->mode(r->as_complex($c))->value, 'complex');
t/basic.t:    is(r->typeof(r->as_complex($c))->value, 'complex');
t/basic.t:  # is_*, as_*, typeof - logical
t/basic.t:    my $x2 = r->as_logical($x1);
t/basic.t:    ok(r->is_logical($x2));
t/basic.t:    is(r->mode($x2)->value, 'logical');
t/basic.t:    is(r->typeof($x2)->value, 'logical');
t/basic.t:  # is_*, as_*, typeof - NULL
t/basic.t:    my $x1 = r->NULL;
t/basic.t:    is(r->mode($x1)->value, 'logical');
t/basic.t:    is(r->typeof($x1)->value, 'logical');
t/basic.t:    is_deeply($mat->values, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
t/basic.t:    is_deeply(r->dim($mat)->values, [2, 5]);
t/basic.t:    ok(r->is_matrix($mat));
t/basic.t:  # matrix - repeat values
t/basic.t:    is_deeply($mat->values, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
t/basic.t:    is_deeply(r->dim($mat)->values, [2, 5]);
t/basic.t:    ok(r->is_matrix($mat));
t/basic.t:  my $v1 = r->rnorm(100);
t/basic.t:  is(r->length($v1)->value, 100);
t/basic.t:  my $v2 = r->sequence($v1);
t/basic.t:  is_deeply($v2->values, [1, 1, 2, 1, 2, 3])
t/basic.t:    my $v2 = r->sample($v1, 50);
t/basic.t:    is(r->length($v2)->value, 50);
t/basic.t:    for my $v2_value (@{$v2->values}) {
t/basic.t:      $duplicate_h->{$v2_value}++;
t/basic.t:      $duplicate = 1 if $duplicate_h->{$v2_value} > 2;
t/basic.t:  # sample - replace => 0
t/basic.t:    my $v2 = r->sample($v1, 50, {replace => 0});
t/basic.t:    is(r->length($v2)->value, 50);
t/basic.t:    for my $v2_value (@{$v2->values}) {
t/basic.t:      $duplicate_h->{$v2_value}++;
t/basic.t:      $duplicate = 1 if $duplicate_h->{$v2_value} > 2;
t/basic.t:  # sample - replace => 0
t/basic.t:    my $v2 = r->sample($v1, 50, {replace => 1});
t/basic.t:    is(r->length($v2)->value, 50);
t/basic.t:    for my $v2_value (@{$v2->values}) {
t/basic.t:  # sample - replace => 0, (strict check)
t/basic.t:    my $v2 = r->sample($v1, 5, {replace => 1});
t/basic.t:    is(r->length($v2)->value, 5);
t/basic.t:    is_deeply($v2->values, [1, 1, 1, 1, 1]);
t/basic.t:    r->set_seed(100);
t/basic.t:    my $v1 = r->runif(5);
t/basic.t:    is_deeply($v1->values, $rands);
t/basic.t:    my $v2 = r->runif(5);
t/basic.t:    isnt($v1->values->[0], $v2->values->[0]);
t/basic.t:    my $v3 = r->runif(5);
t/basic.t:    isnt($v2->values->[0], $v3->values->[0]);
t/basic.t:    my $v4 = r->runif(100);
t/basic.t:    my @in_ranges = grep { $_ >= 0 && $_ <= 1 } @{$v4->values};
t/basic.t:  # runif - min and max
t/basic.t:    r->set_seed(100);
t/basic.t:    my $v1 = r->runif(5, 1, 10);
t/basic.t:    is_deeply($v1->values, $rands);
t/basic.t:    my $v2 = r->runif(100, 1, 2);
t/basic.t:    my @in_ranges = grep { $_ >= 1 && $_ <= 2 } @{$v2->values};
t/basic.t:  my $v2 = r->which($v1, sub { $_ eq 'a' });
t/basic.t:  is_deeply($v2->values, [1, 3]);
t/basic.t:  my $v2 = r->ifelse($v1, 'a', 'b');
t/basic.t:  is_deeply($v2->values, ['a', 'b', 'a']);
t/basic.t:    my $head = r->head($v1);
t/basic.t:    is_deeply($head->values, [1, 2, 3, 4, 5, 6]);
t/basic.t:  # head - values is low than 6
t/basic.t:    my $head = r->head($v1);
t/basic.t:    is_deeply($head->values, [1, 2, 3]);
t/basic.t:  # head - n option
t/basic.t:    my $head = r->head($v1, {n => 3});
t/basic.t:    is_deeply($head->values, [1, 2, 3]);
t/basic.t:  is(r->length($x)->value, 3);
t/basic.t:    is_deeply($x->values, [25]);
t/basic.t:    is_deeply(r->dim($x)->values, [3]);
t/basic.t:  is_deeply($x->get(1)->values, [1]);
t/basic.t:  is_deeply($x->get(3)->values, [3]);
t/basic.t:  $x->at(1)->set(5);;
t/basic.t:  is_deeply($x->get(1)->values, [5]);
t/basic.t:    my $v2 = r->rep($v1, {times => 3});
t/basic.t:    is_deeply($v2->values, [1, 2, 3, 1, 2, 3, 1, 2, 3]);
t/basic.t:    my $v = r->seq(1, 3);
t/basic.t:    is_deeply($v->values, [1, 2, 3]);
t/basic.t:    my $v = r->seq({from => 1, to => 3});
t/basic.t:    is_deeply($v->values, [1, 2, 3]);
t/basic.t:    my $v = r->seq(3, 1);
t/basic.t:    is_deeply($v->values, [3, 2, 1]);
t/basic.t:    my $v = r->seq(2, 2);
t/basic.t:    is_deeply($v->values, [2]);
t/basic.t:    my $v = r->seq(1, 3, {by => 0.5});
t/basic.t:    is_deeply($v->values, [1, 1.5, 2.0, 2.5, 3.0]);
t/basic.t:    my $v = r->seq(3, 1, {by => -0.5});
t/basic.t:    is_deeply($v->values, [3.0, 2.5, 2.0, 1.5, 1.0]);
t/basic.t:    my $v = r->seq(1, 3, {length => 5});
t/basic.t:    is_deeply($v->values, [1, 1.5, 2.0, 2.5, 3.0]);
t/basic.t:  my $v2 = r->seq({along => $v1});
t/basic.t:  is_deeply($v2->values, [1, 2, 3]);
t/factor.t:  # set - basic
t/factor.t:    $x1->at(c(3, 6))->set(c("a2", "a1"));
t/factor.t:    is_deeply($x1->values, [1, 2, 2, 1, 2, 1]);
t/factor.t:    is_deeply(r->levels($x1)->values, ["a1", "a2", "a3"]);
t/factor.t:  # get - drop
t/factor.t:    my $x2 = $x1->get(c(4, 6), {drop => TRUE});
t/factor.t:    ok(r->is_factor($x2));
t/factor.t:    is_deeply($x2->values, [1, 2]);
t/factor.t:    is_deeply(r->levels($x2)->values, ["a1", "a3"]);
t/factor.t:  # get - factor
t/factor.t:    my $x2 = $x1->get(c(4, 6));
t/factor.t:    ok(r->is_factor($x2));
t/factor.t:    is_deeply($x2->values, [1, 3]);
t/factor.t:    is_deeply(r->levels($x2)->values, ["a1", "a2", "a3"]);
t/factor.t:  # get - ordered
t/factor.t:    my $x2 = $x1->get(c(4, 6));
t/factor.t:    ok(r->is_factor($x2));
t/factor.t:    ok(r->is_ordered($x2));
t/factor.t:    is_deeply($x2->values, [1, 3]);
t/factor.t:    is_deeply(r->levels($x2)->values, ["a1", "a2", "a3"]);
t/factor.t:  # nlevels - set values
t/factor.t:    is_deeply($x1->nlevels->values, [2]);
t/factor.t:  # nlevels - function
t/factor.t:    is_deeply(r->nlevels($x1)->values, [2]);
t/factor.t:  # levels - set values
t/factor.t:    r->levels($x1, c("A1", "A2"));
t/factor.t:    is_deeply(r->levels($x1)->values, ["A1", "A2"]);
t/factor.t:  # levels - function
t/factor.t:    r->levels($x1, (c("A1", "A2")));
t/factor.t:    is_deeply(r->levels($x1)->values, ["A1", "A2"]);
t/factor.t:  # interaction - drop
t/factor.t:    my $x3 = r->interaction($x1, $x2, {drop => TRUE});
t/factor.t:    ok(r->is_factor($x3));
t/factor.t:    is_deeply($x3->values, [1, 2, 1, 2]);
t/factor.t:    is_deeply(r->levels($x3)->values, ["a1.b1", "a2.b2"]);
t/factor.t:  # interaction - sep
t/factor.t:    my $x3 = r->interaction($x1, $x2, {sep => ":"});
t/factor.t:    ok(r->is_factor($x3));
t/factor.t:    is_deeply($x3->values, [1, 4, 1, 4]);
t/factor.t:    is_deeply(r->levels($x3)->values, ["a1:b1", "a1:b2", "a2:b1", "a2:b2"]);
t/factor.t:  # interaction - tree elements
t/factor.t:    my $x4 = r->interaction($x1, $x2, $x3);
t/factor.t:    ok(r->is_factor($x4));
t/factor.t:    is_deeply($x4->values, [1, 4, 5]);
t/factor.t:    is_deeply(r->levels($x4)->values, [
t/factor.t:  # interaction - basic 2
t/factor.t:    my $x3 = r->interaction($x1, $x2);
t/factor.t:    ok(r->is_factor($x3));
t/factor.t:    is_deeply($x3->values, [1, 4, 5]);
t/factor.t:    is_deeply(r->levels($x3)->values, ["a1.b1", "a1.b2", "a2.b1", "a2.b2", "a3.b1", "a3.b2"]);
t/factor.t:  # interaction - basic
t/factor.t:    my $x3 = r->interaction($x1, $x2);
t/factor.t:    ok(r->is_factor($x3));
t/factor.t:    is_deeply($x3->values, [1, 4, 1, 4]);
t/factor.t:    is_deeply(r->levels($x3)->values, ["a1.b1", "a1.b2", "a2.b1", "a2.b2"]);
t/factor.t:  # gl - n, k, length
t/factor.t:    my $x1 = r->gl(2, 2, 10);
t/factor.t:    ok(r->is_factor($x1));
t/factor.t:    is_deeply($x1->values, [1, 1, 2, 2, 1, 1, 2, 2, 1, 1]);
t/factor.t:  # gl - n, k ,length, no fit length
t/factor.t:    my $x1 = r->gl(3, 3, 10);
t/factor.t:    ok(r->is_factor($x1));
t/factor.t:    is_deeply($x1->values, [1, 1, 1, 2, 2, 2, 3, 3, 3, 1]);
t/factor.t:  # gl - n, k
t/factor.t:    my $x1 = r->gl(3, 3);
t/factor.t:    ok(r->is_factor($x1));
t/factor.t:    is_deeply($x1->values, [1, 1, 1, 2, 2, 2, 3, 3, 3]);
t/factor.t:    is_deeply(r->levels($x1)->values, ["1", "2", "3"]);
t/factor.t:  # gl - labels
t/factor.t:    my $x1 = r->gl(3, 3, {labels => c("a", "b", "c")});
t/factor.t:    ok(r->is_factor($x1));
t/factor.t:    is_deeply($x1->values, [1, 1, 1, 2, 2, 2, 3, 3, 3]);
t/factor.t:    is_deeply(r->levels($x1)->values, ["a", "b", "c"]);
t/factor.t:  # gl - ordered
t/factor.t:    my $x1 = r->gl(3, 3, {ordered => TRUE});
t/factor.t:    ok(r->is_factor($x1));
t/factor.t:    ok(r->is_ordered($x1));
t/factor.t:    is_deeply($x1->values, [1, 1, 1, 2, 2, 2, 3, 3, 3]);
t/factor.t:    is_deeply(r->levels($x1)->values, ["1", "2", "3"]);
t/factor.t:  # ordered - basic
t/factor.t:    ok(r->is_ordered($x1));
t/factor.t:    ok(r->is_integer($x1));
t/factor.t:    ok(r->is_factor($x1));
t/factor.t:    is_deeply($x1->values, [1, 2, 3, 1, 2 ,3]);
t/factor.t:    is_deeply(r->levels($x1)->values, ["a", "b", "c"]);
t/factor.t:  # ordered - option
t/factor.t:    ok(r->is_ordered($x1));
t/factor.t:    ok(r->is_integer($x1));
t/factor.t:    ok(r->is_factor($x1));
t/factor.t:    is_deeply($x1->values, [1, 2, 3, 1, 2 ,3]);
t/factor.t:    is_deeply(r->levels($x1)->values, ["a", "b", "c"]);
t/factor.t:  # factor - one element
t/factor.t:    is_deeply($x1->values, [1]);
t/factor.t:    is_deeply(r->levels($x1)->values, ["a"]);
t/factor.t:  # factor - as.numeric(levels(f))[f] 
t/factor.t:    my $x1_levels = r->levels($x1);
t/factor.t:    my $x2_levels = r->as_numeric($x1_levels);
t/factor.t:    my $x3 = $x2_levels->get($x1);
t/factor.t:    ok(r->is_numeric($x3));
t/factor.t:    is_deeply($x3->values, [2, 3, 4, 2, 3, 4]);
t/factor.t:  # factor - labels
t/factor.t:    my $x2 = r->labels($x1);
t/factor.t:    ok(r->is_character($x2));
t/factor.t:    is_deeply($x2->values, ["a", "b", "c", "a", "b", "c"]);
t/factor.t:  # factor - as_character
t/factor.t:    my $x2 = r->as_character($x1);
t/factor.t:    ok(r->is_character($x2));
t/factor.t:    is_deeply($x2->values, ["a", "b", "c", "a", "b", "c"]);
t/factor.t:  # factor - as_logical
t/factor.t:    my $x2 = r->as_logical($x1);
t/factor.t:    ok(r->is_logical($x2));
t/factor.t:    is_deeply($x2->values, [1, 1, 1]);
t/factor.t:  # factor - as_complex
t/factor.t:    my $x2 = r->as_complex($x1);
t/factor.t:    ok(r->is_complex($x2));
t/factor.t:    is_deeply($x2->values, [{re => 1, im =>  0}, {re => 2, im => 0}, {re => 3, im => 0}]);
t/factor.t:  # factor - as_double
t/factor.t:    my $x2 = r->as_double($x1);
t/factor.t:    ok(r->is_double($x2));
t/factor.t:    is_deeply($x2->values, [1, 2, 3]);
t/factor.t:  # factor - as_integer
t/factor.t:    my $x2 = r->as_integer($x1);
t/factor.t:    ok(r->is_integer($x2));
t/factor.t:    is_deeply($x2->values, [1, 2, 3]);
t/factor.t:  # factor - as_factor, double
t/factor.t:    ok(r->is_factor($x2));
t/factor.t:    is_deeply($x2->values, [1, 2, 3]);
t/factor.t:    is_deeply(r->levels($x2)->values, ["2", "3", "4"]);
t/factor.t:  # factor - as_factor, character
t/factor.t:    ok(r->is_factor($x2));
t/factor.t:    is_deeply($x2->values, [1, 2, 3]);
t/factor.t:    is_deeply(r->levels($x2)->values, ["a", "b", "c"]);
t/factor.t:  # factor - ordered
t/factor.t:    ok(r->is_ordered($x1));
t/factor.t:  # factor - ordered, default, FALSE
t/factor.t:    ok(!r->is_ordered($x1));
t/factor.t:  # factor - exclude
t/factor.t:    is_deeply($x1->values, [1, 2, undef, 1, 2, undef]);
t/factor.t:  # factor - labels
t/factor.t:  # factor - labels, one element
t/factor.t:  # factor - to_string
t/factor.t:  # factor - to_string, ordered
t/factor.t:  # factor - levels
t/factor.t:    is_deeply($x1->values, [1, 2, undef, 1, 2 ,undef]);
t/factor.t:    is_deeply(r->levels($x1)->values, ["a", "b"]);
t/factor.t:  # factor - basic
t/factor.t:    ok(r->is_integer($x1));
t/factor.t:    ok(r->is_factor($x1));
t/factor.t:    is_deeply($x1->values, [1, 2, 3, 1, 2 ,3]);
t/factor.t:    is_deeply(r->levels($x1)->values, ["a", "b", "c"]);
t/util.t:#   get - logical, undef
t/util.t:  # looks_like_logical - "TRUE"
t/util.t:  # looks_like_logical - "  TRUE  "
t/util.t:  # looks_like_logical - "T"
t/util.t:  # looks_like_logical - "FALSE"
t/util.t:  # looks_like_logical - "F"
t/util.t:  # looks_like_logical - "abc"
t/util.t:  # looks_like_complex - "abc"
t/util.t:  # looks_like_complex - "2i"
t/util.t:    cmp_ok($ret->{re}, "==", 0);
t/util.t:    cmp_ok($ret->{im}, "==", 2);
t/util.t:  # looks_like_complex - "2.3i"
t/util.t:    cmp_ok($ret->{re}, "==", 0);
t/util.t:    cmp_ok($ret->{im}, "==", 2.3);
t/util.t:  # looks_like_complex - "-2.3i"
t/util.t:    my $num_str = "-2.3i";
t/util.t:    cmp_ok($ret->{re}, "==", 0);
t/util.t:    cmp_ok($ret->{im}, "==", -2.3);
t/util.t:  # looks_like_complex - "  2.3i  "
t/util.t:    cmp_ok($ret->{re}, "==", 0);
t/util.t:    cmp_ok($ret->{im}, "==", 2.3);
t/util.t:  # looks_like_complex - "1.2+2.3i"
t/util.t:    cmp_ok($ret->{re}, "==", 1.2);
t/util.t:    cmp_ok($ret->{im}, "==", 2.3);
t/util.t:  # looks_like_complex - "  1.2  +  2.3i  "
t/util.t:    cmp_ok($ret->{re}, "==", 1.2);
t/util.t:    cmp_ok($ret->{im}, "==", 2.3);
t/util.t:  # looks_like_complex - "-1.2-2.3i"
t/util.t:    my $num_str = "-1.2-2.3i";
t/util.t:    cmp_ok($ret->{re}, "==", -1.2);
t/util.t:    cmp_ok($ret->{im}, "==", -2.3);
t/util.t:  # looks_like_double - 5.23
t/util.t:  # looks_like_double - 5
t/util.t:  # pos_to_index - last position
t/util.t:  # pos_to_index - some position
t/util.t:  # pos_to_index - first position
t/array-operator.t:  # numeric operator - -0.2 * -Inf
t/array-operator.t:    my $x1 = c(-0.2);
t/array-operator.t:    my $x2 = c(-Inf);
t/array-operator.t:    is_deeply($x3->values, ['Inf']);
t/array-operator.t:  # numeric operator - -Inf + 2i
t/array-operator.t:    my $x1 = c(-Inf);
t/array-operator.t:    is($x3->value->{re}, '-Inf');
t/array-operator.t:    is($x3->value->{im}, 2);
t/array-operator.t:  # comparison operator numeric - <
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [1, 0, 0]);
t/array-operator.t:  # comparison operator numeric - <, arguments count is different
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [1, 0, 0]);
t/array-operator.t:  # comparison operator numeric - <=
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [1, 0, 1]);
t/array-operator.t:  # comparison operator numeric - <=, arguments count is different
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [1, 1, 0]);
t/array-operator.t:  # comparison operator numeric - >
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [0, 1, 0]);
t/array-operator.t:  # comparison operator numeric - >, arguments count is different
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [0, 0, 1]);
t/array-operator.t:  # comparison operator numeric - >=
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [0, 1, 1]);
t/array-operator.t:  # comparison operator numeric - >=, arguments count is different
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [0, 1, 1]);
t/array-operator.t:  # comparison operator numeric - ==
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [0, 1]);
t/array-operator.t:  # comparison operator numeric - ==, arguments count is different
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [0, 1]);
t/array-operator.t:  # comparison operator numeric - !=
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [1, 0]);
t/array-operator.t:  # comparison operator numeric - !=, arguments count is different
t/array-operator.t:    ok(r->is_logical($x3));
t/array-operator.t:    is_deeply($x3->values, [1, 0]);
t/vector-inf.t:  # Inf - negation repeat
t/vector-inf.t:    ok($inf2->value, 'Inf');
t/vector-inf.t:  # Inf - to_string, plus
t/vector-inf.t:  # Inf - negation
t/vector-inf.t:    is($negative_inf->value, '-Inf');
t/vector-inf.t:  # Inf - to_string, minus
t/vector-inf.t:    my $negative_inf = Rstats::VectorFunc::new_double('-Inf');
t/vector-inf.t:    is("$negative_inf", '-Inf');
t/vector-inf.t:  # is_infinite - Inf, true
t/vector-inf.t:    ok($inf->is_infinite->value);
t/vector-inf.t:  # is_infinite - -Inf, true
t/vector-inf.t:    my $negative_inf = Rstats::VectorFunc::new_double('-Inf');
t/vector-inf.t:    ok($negative_inf->is_infinite->value);
t/vector-inf.t:  # is_infinite - Double, false
t/vector-inf.t:    ok(!$num->is_infinite->value);
t/vector-inf.t:  # is_finite - Inf, false
t/vector-inf.t:    ok(!$inf->is_finite->value);
t/vector-inf.t:  # is_finite - -Inf, false
t/vector-inf.t:    my $negative_inf = Rstats::VectorFunc::new_double('-Inf');
t/vector-inf.t:    ok(!$negative_inf->is_finite->value);
t/vector-inf.t:  # is_finite - Double, true
t/vector-inf.t:    ok($num->is_finite->value);
t/vector-inf.t:  # is_finite - Integer, true
t/vector-inf.t:    ok($num->is_finite->value);
t/functions-apply.t:  my $x2 = r->lapply($x1, 'sum');
t/functions-apply.t:  ok(r->is_list($x2));
t/functions-apply.t:  is_deeply($x2->getin(1)->values, [3]);
t/functions-apply.t:  is_deeply($x2->getin(2)->values, [7]);
t/functions-apply.t:  # sweep - margin 1, %
t/functions-apply.t:    my $x2 = r->sweep($x1, 1, c(1, 2, 3), {FUN => '%'});
t/functions-apply.t:    is_deeply($x2->values, [qw/0 0 0 0 1 0/]);
t/functions-apply.t:    is_deeply($x2->dim->values, [3, 2]);
t/functions-apply.t:  # sweep - margin 1, **
t/functions-apply.t:    my $x2 = r->sweep($x1, 1, c(1, 2, 3), {FUN => '**'});
t/functions-apply.t:    is_deeply($x2->values, [qw/1 4 27 4 25 216/]);
t/functions-apply.t:    is_deeply($x2->dim->values, [3, 2]);
t/functions-apply.t:  # sweep - margin 1, /
t/functions-apply.t:    my $x2 = r->sweep($x1, 1, c(1, 2, 3), {FUN => '/'});
t/functions-apply.t:    is_deeply($x2->values, [qw/1 1 1 4 2.5 2/]);
t/functions-apply.t:    is_deeply($x2->dim->values, [3, 2]);
t/functions-apply.t:  # sweep - margin 1, *
t/functions-apply.t:    my $x2 = r->sweep($x1, 1, c(1, 2, 3), {FUN => '*'});
t/functions-apply.t:    is_deeply($x2->values, [qw/1 4 9 4 10 18/]);
t/functions-apply.t:    is_deeply($x2->dim->values, [3, 2]);
t/functions-apply.t:  # sweep - margin 1, -
t/functions-apply.t:    my $x2 = r->sweep($x1, 1, c(1, 2, 3), {FUN => '-'});
t/functions-apply.t:    is_deeply($x2->values, [qw/0 0 0 3 3 3/]);
t/functions-apply.t:    is_deeply($x2->dim->values, [3, 2]);
t/functions-apply.t:  # sweep - margin 1, +
t/functions-apply.t:    my $x2 = r->sweep($x1, 1, c(1, 2, 3), {FUN => '+'});
t/functions-apply.t:    is_deeply($x2->values, [qw/2 4 6 5 7 9/]);
t/functions-apply.t:    is_deeply($x2->dim->values, [3, 2]);
t/functions-apply.t:  # sweep - margin 1
t/functions-apply.t:    my $x2 = r->sweep($x1, 1, c(1, 2, 3));
t/functions-apply.t:    is_deeply($x2->values, [qw/0 0 0 3 3 3/]);
t/functions-apply.t:    is_deeply($x2->dim->values, [3, 2]);
t/functions-apply.t:  # sweep - margin 2
t/functions-apply.t:    my $x2 = r->sweep($x1, 2, c(1, 2));
t/functions-apply.t:    is_deeply($x2->values, [qw/0 1 2 2 3 4/]);
t/functions-apply.t:  # sweep - margin 1, 2
t/functions-apply.t:    my $x3 = r->sweep($x1, c(1, 2), $x2);
t/functions-apply.t:    is_deeply($x3->values, [qw/-1 -1 -1 -1 -1 -1/]);
t/functions-apply.t:  # mapply - same length
t/functions-apply.t:    my $x3 = r->mapply('rep', $x1, $x2);
t/functions-apply.t:    ok(r->is_list($x3));
t/functions-apply.t:    is_deeply($x3->getin(1)->values, [1, 1, 1]);
t/functions-apply.t:    is_deeply($x3->getin(2)->values, [2, 2]);
t/functions-apply.t:    is_deeply($x3->getin(3)->values, [3]);
t/functions-apply.t:  # mapply - different length
t/functions-apply.t:    my $x3 = r->mapply('rep', $x1, $x2);
t/functions-apply.t:    ok(r->is_list($x3));
t/functions-apply.t:    is_deeply($x3->getin(1)->values, [1, 1, 1, 1, 1, 1]);
t/functions-apply.t:    is_deeply($x3->getin(6)->values, [3]);
t/functions-apply.t:  # mapply - only first element
t/functions-apply.t:    my $x3 = r->mapply('rep', $x1, $x2);
t/functions-apply.t:    is_deeply($x3->values, [1, 1, 1]);
t/functions-apply.t:  my $x3 = r->tapply($x1, $x2, 'mean');
t/functions-apply.t:  is_deeply($x3->values, [3.5, 3]);
t/functions-apply.t:  is_deeply($x3->names->values, ["L", "M"]);
t/functions-apply.t:  is_deeply($x3->dim->values, [2]);
t/functions-apply.t:  my $x2 = r->sapply($x1, 'sum');
t/functions-apply.t:  ok(r->is_vector($x2));
t/functions-apply.t:  is_deeply($x2->values, [3, 7.4]);
t/functions-apply.t:  # apply - code reference
t/functions-apply.t:    my $x2 = r->apply($x1, 1, sub { r->sum($_[0]) });
t/functions-apply.t:    is_deeply($x2->values, [qw/66 72 78 84/]);
t/functions-apply.t:    is_deeply($x2->dim->values, []);
t/functions-apply.t:  # apply - three dimention, margin 3,2
t/functions-apply.t:    my $x2 = r->apply($x1, c(3, 2), 'sum');
t/functions-apply.t:    is_deeply($x2->values, [qw/10 58 26 74 42 90/]);
t/functions-apply.t:    is_deeply($x2->dim->values, [qw/2 3/]);
t/functions-apply.t:  # apply - three dimention, margin 2,3
t/functions-apply.t:    my $x2 = r->apply($x1, c(2, 3), 'sum');
t/functions-apply.t:    is_deeply($x2->values, [qw/10 26 42 58 74 90/]);
t/functions-apply.t:    is_deeply($x2->dim->values, [qw/3 2/]);
t/functions-apply.t:  # apply - three dimention, margin 1, 2
t/functions-apply.t:    my $x2 = r->apply($x1, c(1, 2), 'sum');
t/functions-apply.t:    is_deeply($x2->values, [qw/14 16 18 20 22 24 26 28 30 32 34 36/]);
t/functions-apply.t:    is_deeply($x2->dim->values, [qw/4 3/]);
t/functions-apply.t:  # apply - three dimention, margin 1
t/functions-apply.t:    my $x2 = r->apply($x1, 1, 'sum');
t/functions-apply.t:    is_deeply($x2->values, [qw/66 72 78 84/]);
t/functions-apply.t:    is_deeply($x2->dim->values, []);
t/functions-apply.t:  # apply - three dimention, margin 2
t/functions-apply.t:    my $x2 = r->apply($x1, 2, 'sum');
t/functions-apply.t:    is_deeply($x2->values, [qw/68 100 132/]);
t/functions-apply.t:    is_deeply($x2->dim->values, []);
t/functions-apply.t:  # apply - three dimention, margin 3
t/functions-apply.t:    my $x2 = r->apply($x1, 3, 'sum');
t/functions-apply.t:    is_deeply($x2->values, [qw/78 222/]);
t/functions-apply.t:    is_deeply($x2->dim->values, []);
t/functions-apply.t:  # apply - two dimention, margin 1
t/functions-apply.t:    my $x2 = r->apply($x1, 1, 'sum');
t/functions-apply.t:    is_deeply($x2->values, [9, 12]);
t/functions-apply.t:    is_deeply($x2->dim->values, []);
t/functions-apply.t:  # apply - two dimention, margin 2
t/functions-apply.t:    my $x2 = r->apply($x1, 2, 'sum');
t/functions-apply.t:    is_deeply($x2->values, [3, 7, 11]);
t/functions-apply.t:    is_deeply($x2->dim->values, []);
t/functions-apply.t:  # apply - two dimention, margin 1, 2
t/functions-apply.t:    my $x2 = r->apply($x1, c(1, 2), 'sqrt');
t/functions-apply.t:    is_deeply($x2->values, [1, 2, 3, 4, 5, 6]);
t/functions-apply.t:    is_deeply($x2->dim->values, [2, 3]);
t/matrix.t:  # matrix - byrow
t/matrix.t:    is_deeply($m1->values, [(1, 5, 9), (2, 6, 10), (3, 7,11), (4, 8, 12)]);
t/matrix.t:    is_deeply(r->dim($m1)->values, [3, 4]);
t/matrix.t:    ok(r->is_matrix($m1));
t/matrix.t:  # matrix - omit col
t/matrix.t:    is_deeply($m1->values, [1 .. 12]);
t/matrix.t:    is_deeply(r->dim($m1)->values, [3, 4]);
t/matrix.t:    ok(r->is_matrix($m1));
t/matrix.t:  # matrix - basic
t/matrix.t:    is_deeply($m1->values, [1 .. 12]);
t/matrix.t:    is_deeply(r->dim($m1)->values, [3, 4]);
t/matrix.t:    ok(r->is_matrix($m1));
t/matrix.t:  # matrix - omit row
t/matrix.t:    is_deeply($m1->values, [1 .. 12]);
t/matrix.t:    is_deeply(r->dim($m1)->values, [3, 4]);
t/matrix.t:    ok(r->is_matrix($m1));
t/matrix.t:  # matrix - omit col
t/matrix.t:    is_deeply($m1->values, [1 .. 12]);
t/matrix.t:    is_deeply(r->dim($m1)->values, [12, 1]);
t/matrix.t:    ok(r->is_matrix($m1));
t/matrix.t:  # matrix - nrow and ncol option
t/matrix.t:    is_deeply($m1->values, [1 .. 12]);
t/matrix.t:    is_deeply(r->dim($m1)->values, [4, 3]);
t/matrix.t:    ok(r->is_matrix($m1));
t/matrix.t:  # matrix - repeat
t/matrix.t:    is_deeply($m1->values, [(1 .. 3) x 4]);
t/matrix.t:    is_deeply(r->dim($m1)->values, [3, 4]);
t/matrix.t:    ok(r->is_matrix($m1));
t/matrix.t:  # matrix - repeat 2
t/matrix.t:    is_deeply($m1->values, [1 .. 10, 1, 2]);
t/matrix.t:    is_deeply(r->dim($m1)->values, [3, 4]);
t/matrix.t:    ok(r->is_matrix($m1));
t/matrix.t:  # matrix - repeat 3
t/matrix.t:    is_deeply($m1->values, [(0) x 12]);
t/matrix.t:    is_deeply(r->dim($m1)->values, [3, 4]);
t/matrix.t:    ok(r->is_matrix($m1));
t/matrix.t:  # rownames and colnames - accessor
t/matrix.t:    r->colnames($m1,c(qw/c1 c2 c3/));
t/matrix.t:    is_deeply(r->colnames($m1)->values, [qw/c1 c2 c3/]);
t/matrix.t:    r->rownames($m1, c(qw/r1 r2 r3/));
t/matrix.t:    is_deeply(r->rownames($m1)->values, [qw/r1 r2 r3/]);
t/matrix.t:  # rownames and colnames - to_string
t/matrix.t:    r->colnames($m1, c(qw/c1 c2 c3/));
t/matrix.t:    r->rownames($m1, c(qw/r1 r2 r3/));
t/matrix.t:  # upper_tri - basic
t/matrix.t:    my $x2 = r->lower_tri($x1);
t/matrix.t:    is_deeply($x2->values, [
t/matrix.t:    is_deeply(r->dim($x2)->values, [3, 4]);
t/matrix.t:  # upper_tri - diag = TRUE
t/matrix.t:    my $x2 = r->lower_tri($x1, {diag => TRUE});
t/matrix.t:    is_deeply($x2->values, [
t/matrix.t:    is_deeply(r->dim($x2)->values, [3, 4]);
t/matrix.t:  # upper_tri - basic
t/matrix.t:    my $x2 = r->upper_tri($x1);
t/matrix.t:    is_deeply($x2->values, [
t/matrix.t:    is_deeply(r->dim($x2)->values, [3, 4]);
t/matrix.t:  # upper_tri - diag = TRUE
t/matrix.t:    my $x2 = r->upper_tri($x1, {diag => TRUE});
t/matrix.t:    is_deeply($x2->values, [
t/matrix.t:    is_deeply(r->dim($x2)->values, [3, 4]);
t/matrix.t:  # t - basic
t/matrix.t:    my $m2 = r->t($m1);
t/matrix.t:    is_deeply($m2->values, [1, 4, 2, 5, 3, 6]);
t/matrix.t:    is_deeply(r->dim($m2)->values, [2, 3]);
t/matrix.t:  my $m1 = r->cbind(
t/matrix.t:  is_deeply($m1->values, [1 .. 12]);
t/matrix.t:  is_deeply(r->dim($m1)->values, [4, 3]);
t/matrix.t:  my $m1 = r->rbind(
t/matrix.t:  is_deeply($m1->values, [1, 5, 9, 2, 6, 10, 3, 7, 11, 4, 8, 12]);
t/matrix.t:  is_deeply(r->dim($m1)->values, [3, 4]);
t/matrix.t:  my $v1 = r->rowSums($m1);
t/matrix.t:  is_deeply($v1->values,[10, 26, 42]);
t/matrix.t:  is_deeply(r->dim($v1)->values, []);
t/matrix.t:  my $v1 = r->rowMeans($m1);
t/matrix.t:  is_deeply($v1->values,[10/4, 26/4, 42/4]);
t/matrix.t:  is_deeply(r->dim($v1)->values, []);
t/matrix.t:  my $v1 = r->colSums($m1);
t/matrix.t:  is_deeply($v1->values,[15, 18, 21, 24]);
t/matrix.t:  is_deeply(r->dim($v1)->values, []);
t/matrix.t:  my $v1 = r->colMeans($m1);
t/matrix.t:  is_deeply($v1->values,[15/3, 18/3, 21/3, 24/3]);
t/matrix.t:  is_deeply(r->dim($v1)->values, []);
t/matrix.t:  my $m2 = r->row($m1);
t/matrix.t:  is_deeply($m2->values,[1,2,3,1,2,3,1,2,3,1,2,3]);
t/matrix.t:  is_deeply(r->dim($m2)->values, [3, 4]);
t/matrix.t:  my $m2 = r->col($m1);
t/matrix.t:  is_deeply($m2->values,[1,1,1,2,2,2,3,3,3,4,4,4]);
t/matrix.t:  is_deeply(r->dim($m2)->values, [3, 4]);
t/matrix.t:  is_deeply(r->nrow($m1)->values, [3]);
t/matrix.t:  is_deeply(r->ncol($m1)->values, [4]);
lib/Rstats/Class.pm:use Object::Simple -base;
lib/Rstats/Class.pm:  my $self = shift->SUPER::new(@_);
lib/Rstats/Class.pm:    $self->helper($func_name => $func);
lib/Rstats/Class.pm:    $self->helper($func_name => sub { $func->($self, @_) });
lib/Rstats/Class.pm:    unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
lib/Rstats/Class.pm:    unless my $helper = $self->helpers->{$method};
lib/Rstats/Class.pm:  return $helper->(@_);
lib/Rstats/Class.pm:  $self->helpers({%{$self->helpers}, %$helpers});
lib/Rstats/Class.pm:Rstats::Class - Rstats Object-Oriented interface
lib/Rstats/Class.pm:  my $r = Rstats::Class->new;
lib/Rstats/Class.pm:  my $v1 = $r->c([1, 2, 3]);
lib/Rstats/Class.pm:  my $v2 = $r->c([2, 3, 4]);
lib/Rstats/DataFrame.pm:use Rstats::List -base;
lib/Rstats/DataFrame.pm:    $col_index_values = [1 .. $self->names->length_value];
lib/Rstats/DataFrame.pm:    for my $col_index_value (@{$col_index->values}) {
lib/Rstats/DataFrame.pm:      push @$col_index_values, $self->_name_to_index($col_index_value);
lib/Rstats/DataFrame.pm:    my $tmp_col_index_values = $col_index->values;
lib/Rstats/DataFrame.pm:      push @$col_index_values, $i + 1 if $tmp_col_index_values->[$i];
lib/Rstats/DataFrame.pm:    my $col_index_values_tmp = $col_index->values;
lib/Rstats/DataFrame.pm:    if ($col_index_values_tmp->[0] < 0) {
lib/Rstats/DataFrame.pm:        $delete_col_index_values_h->{-$index} = 1;
lib/Rstats/DataFrame.pm:      for (my $index = 1; $index <= $self->names->length_value; $index++) {
lib/Rstats/DataFrame.pm:        push @$col_index_values, $index unless $delete_col_index_values_h->{$index};
lib/Rstats/DataFrame.pm:  my $elements = $self->list;
lib/Rstats/DataFrame.pm:    push @$new_elements, $elements->[$i - 1];
lib/Rstats/DataFrame.pm:    $new_element = $new_element->get($row_index)
lib/Rstats/DataFrame.pm:  my $data_frame = Rstats::DataFrame->new;
lib/Rstats/DataFrame.pm:  $data_frame->list($new_elements);
lib/Rstats/DataFrame.pm:  $self->copy_attrs_to($data_frame, {new_indexes => [$row_index, Rstats::ArrayFunc::c(@$col_index_values)]});
lib/Rstats/DataFrame.pm:  $data_frame->{dimnames}[0] = Rstats::VectorFunc::new_character(1 .. $data_frame->getin(1)->length_value);
lib/Rstats/DataFrame.pm:  my $t = Text::UnicodeTable::Simple->new(border => 0, alignment => 'right');
lib/Rstats/DataFrame.pm:  my $column_names = $self->names->values;
lib/Rstats/DataFrame.pm:  $t->set_header('', @$column_names);
lib/Rstats/DataFrame.pm:    my $x = $self->getin($i);
lib/Rstats/DataFrame.pm:    push @$columns, $x->values;
lib/Rstats/DataFrame.pm:  my $row_count = @{$columns->[0]};
lib/Rstats/DataFrame.pm:      push @row, $columns->[$k][$i];
lib/Rstats/DataFrame.pm:    $t->add_row(@row);
lib/Rstats/DataFrame.pm:Rstats::DataFrame - Data frame
lib/Rstats/List.pm:use Rstats::Container -base;
lib/Rstats/List.pm:    $_index = $self->at;
lib/Rstats/List.pm:  $self->at($_index);
lib/Rstats/List.pm:    $index = $self->_name_to_index($x1_index);
lib/Rstats/List.pm:    $index = $x1_index->values->[0];
lib/Rstats/List.pm:  my $elements = $self->list;
lib/Rstats/List.pm:  my $element = $elements->[$index - 1];
lib/Rstats/List.pm:  my $elements = $self->list;
lib/Rstats/List.pm:  my $list = $class->new;
lib/Rstats/List.pm:  my $list_elements = $list->list;
lib/Rstats/List.pm:    for my $value (@{$index->values}) {
lib/Rstats/List.pm:      push @$index_values, $self->_name_to_index($value);
lib/Rstats/List.pm:    $index_values = $index->values;
lib/Rstats/List.pm:    push @$list_elements, $elements->[$i - 1];
lib/Rstats/List.pm:  $self->copy_attrs_to($list, {new_indexes => [Rstats::ArrayFunc::c(@$index_values)]});
lib/Rstats/List.pm:  my $_index = $self->at;
lib/Rstats/List.pm:    $index = $self->_name_to_index($x1_index);
lib/Rstats/List.pm:    $index = $x1_index->values->[0];
lib/Rstats/List.pm:    splice @{$self->list}, $index - 1, 1;
lib/Rstats/List.pm:    if (exists $self->{names}) {
lib/Rstats/List.pm:      my $new_names_values = $self->{names}->values;
lib/Rstats/List.pm:      splice @$new_names_values, $index - 1, 1;
lib/Rstats/List.pm:      $self->{names} = Rstats::VectorFunc::new_character(@$new_names_values);
lib/Rstats/List.pm:    if (exists $self->{dimnames}) {
lib/Rstats/List.pm:      my $new_dimname_values = $self->{dimnames}[1]->values;
lib/Rstats/List.pm:      splice @$new_dimname_values, $index - 1, 1;
lib/Rstats/List.pm:      $self->{dimnames}[1] = Rstats::VectorFunc::new_character(@$new_dimname_values);
lib/Rstats/List.pm:    if ($self->is_data_frame) {
lib/Rstats/List.pm:      my $self_length = $self->length_value;
lib/Rstats/List.pm:      my $v1_length = $v1->length_value;
lib/Rstats/List.pm:    $self->list->[$index - 1] = $v1;
lib/Rstats/List.pm:  $self->_to_string($self, $poses, \$str);
lib/Rstats/List.pm:  my $elements = $list->list;
lib/Rstats/List.pm:    my $element = $elements->[$i];
lib/Rstats/List.pm:      $self->_to_string($element, $poses, $str_ref);
lib/Rstats/List.pm:      $$str_ref .= $element->to_string . "\n";
lib/Rstats/List.pm:Rstats::List - List
lib/Rstats/Container.pm:use Object::Simple -base;
lib/Rstats/Container.pm:Rstats::Container - Container base class
lib/Rstats/Func.pm:  my $x_margin_values = $x_margin->values;
lib/Rstats/Func.pm:  my $func = defined $x_func ? $x_func->value : '-';
lib/Rstats/Func.pm:  my $x2_dim_values = $x2->dim->values;
lib/Rstats/Func.pm:  my $x1_dim_values = $x1->dim->values;
lib/Rstats/Func.pm:  my $x1_length = $x1->length_value;
lib/Rstats/Func.pm:      push @$new_index, $x1_index->[$x_margin_value - 1];
lib/Rstats/Func.pm:    my $e1 = $x2->value(@{$new_index});
lib/Rstats/Func.pm:  elsif ($func eq '-') {
lib/Rstats/Func.pm:    $x4 = $x1 - $x3;
lib/Rstats/Func.pm:  $x1->copy_attrs_to($x4);
lib/Rstats/Func.pm:  $r->{seed} = $seed;
lib/Rstats/Func.pm:  my $count = $x_count->value;
lib/Rstats/Func.pm:  my $min = defined $x_min ? $x_min->value : 0;
lib/Rstats/Func.pm:  my $max = defined $x_max ? $x_max->value : 1;
lib/Rstats/Func.pm:  my $diff = $max - $min;
lib/Rstats/Func.pm:  if (defined $r->{seed}) {
lib/Rstats/Func.pm:    srand $r->{seed};
lib/Rstats/Func.pm:  $r->{seed} = undef;
lib/Rstats/Func.pm:  my $func = ref $func_name ? $func_name : $r->helpers->{$func_name};
lib/Rstats/Func.pm:  my $dim_values = $x1->dim->values;
lib/Rstats/Func.pm:  my $margin_values = $x_margin->values;
lib/Rstats/Func.pm:    push @$new_dim_values, $dim_values->[$i - 1];
lib/Rstats/Func.pm:  my $x1_length = $x1->length_value;
lib/Rstats/Func.pm:    my $e1 = $x1->value(@$index);
lib/Rstats/Func.pm:      push @$new_index, $index->[$i - 1];
lib/Rstats/Func.pm:    $new_elements_array->[$new_pos] ||= [];
lib/Rstats/Func.pm:    push @{$new_elements_array->[$new_pos]}, $e1;
lib/Rstats/Func.pm:    push @$new_elements, $func->(Rstats::ArrayFunc::c(@$element_array));
lib/Rstats/Func.pm:  $x2->vector(Rstats::ArrayFunc::c(@$new_elements)->vector);
lib/Rstats/Func.pm:  $x1->copy_attrs_to($x1);
lib/Rstats/Func.pm:  $x2->{dim} = Rstats::VectorFunc::new_integer(@$new_dim_values);
lib/Rstats/Func.pm:  if ($x2->{dim}->length_value == 1) {
lib/Rstats/Func.pm:    delete $x2->{dim};
lib/Rstats/Func.pm:  my $func = ref $func_name ? $func_name : $r->helpers->{$func_name};
lib/Rstats/Func.pm:  my @xs_length = map { $_->length_value } @xs;
lib/Rstats/Func.pm:    if ($x->length_value < $max_length) {
lib/Rstats/Func.pm:    my @args = map { $_->value($i + 1) } @xs;
lib/Rstats/Func.pm:    my $x = $func->(@args);
lib/Rstats/Func.pm:    return $new_xs->[0];
lib/Rstats/Func.pm:  my $func = ref $func_name ? $func_name : $r->helpers->{$func_name};
lib/Rstats/Func.pm:  my $x1_values = $x1->values;
lib/Rstats/Func.pm:  my $x2_values = $x2->values;
lib/Rstats/Func.pm:  for (my $i = 0; $i < $x1->length_value; $i++) {
lib/Rstats/Func.pm:    my $x1_value = $x1_values->[$i];
lib/Rstats/Func.pm:    my $index = $x2_values->[$i];
lib/Rstats/Func.pm:    $new_values->[$index] ||= [];
lib/Rstats/Func.pm:    push @{$new_values->[$index]}, $x1_value;
lib/Rstats/Func.pm:    my $x = $func->(Rstats::ArrayFunc::c(@{$new_values->[$i]}));
lib/Rstats/Func.pm:  $x4->names(Rstats::Func::levels(undef(), $x2));
lib/Rstats/Func.pm:  my $func = ref $func_name ? $func_name : $r->helpers->{$func_name};
lib/Rstats/Func.pm:  for my $element (@{$x1->list}) {
lib/Rstats/Func.pm:    push @$new_elements, $func->($element);
lib/Rstats/Func.pm:  $x1->copy_attrs_to($x2);
lib/Rstats/Func.pm:  my $x1 = $r->lapply(@_);
lib/Rstats/Func.pm:  my $x2 = Rstats::ArrayFunc::c(@{$x1->list});
lib/Rstats/Func.pm:  if (exists $x1->{vector}) {
lib/Rstats/Func.pm:    return $x1->vector->decompose;
lib/Rstats/Func.pm:  my $new_indexes = $opt->{new_indexes};
lib/Rstats/Func.pm:  my $exclude = $opt->{exclude} || [];
lib/Rstats/Func.pm:  $x2->{dim} = $x1->{dim}->clone if !$exclude_h{dim} && exists $x1->{dim};
lib/Rstats/Func.pm:  $x2->{class} =  $x1->{class}->clone if !$exclude_h{class} && exists $x1->{class};
lib/Rstats/Func.pm:  $x2->{levels} = $x1->{levels}->clone if !$exclude_h{levels} && exists $x1->{levels};
lib/Rstats/Func.pm:  if (!$exclude_h{names} && exists $x1->{names}) {
lib/Rstats/Func.pm:    my $index = Rstats::Func::is_data_frame(undef(), $x1) ? $new_indexes->[1] : $new_indexes->[0];
lib/Rstats/Func.pm:      my $x1_names_values = $x1->{names}->values;
lib/Rstats/Func.pm:      for my $i (@{$index->values}) {
lib/Rstats/Func.pm:        push @$x2_names_values, $x1_names_values->[$i - 1];
lib/Rstats/Func.pm:      $x2_names_values = $x1->{names}->values;
lib/Rstats/Func.pm:    $x2->{names} = Rstats::VectorFunc::new_character(@$x2_names_values);
lib/Rstats/Func.pm:  if (!$exclude_h{dimnames} && exists $x1->{dimnames}) {
lib/Rstats/Func.pm:    my $dimnames = $x1->{dimnames};
lib/Rstats/Func.pm:      my $dimname = $dimnames->[$i];
lib/Rstats/Func.pm:      if (defined $dimname && $dimname->length_value) {
lib/Rstats/Func.pm:        my $index = $new_indexes->[$i];
lib/Rstats/Func.pm:        my $dimname_values = $dimname->values;
lib/Rstats/Func.pm:          for my $k (@{$index->values}) {
lib/Rstats/Func.pm:            push @$new_dimname_values, $dimname_values->[$k - 1];
lib/Rstats/Func.pm:    $x2->{dimnames} = $new_dimnames;
lib/Rstats/Func.pm:      my $re = $value->{re} || 0;
lib/Rstats/Func.pm:      my $im = $value->{im} || 0;
lib/Rstats/Func.pm:    my $type = $x1->vector->type;
lib/Rstats/Func.pm:    my $length = $x1->length_value;
lib/Rstats/Func.pm:    if (exists $x1->{dim}) {
lib/Rstats/Func.pm:      my $dim_values = $x1->{dim}->values;
lib/Rstats/Func.pm:      for (my $i = 0; $i < $x1->{dim}->length_value; $i++) {
lib/Rstats/Func.pm:        my $d = $dim_values->[$i];
lib/Rstats/Func.pm:        if ($x1->{dim}->length_value == 1) {
lib/Rstats/Func.pm:    my $values = $x1->values;
lib/Rstats/Func.pm:      push @element_str, $x1->_value_to_string($values->[$i], $type);
lib/Rstats/Func.pm:    $x1->{levels} = $x_levels->vector->clone;
lib/Rstats/Func.pm:    if (exists $x1->{levels}) {
lib/Rstats/Func.pm:      $x_levels->vector($x1->{levels}->clone);
lib/Rstats/Func.pm:  $clone->vector($x1->vector->clone);
lib/Rstats/Func.pm:  $x1->copy_attrs_to($clone);
lib/Rstats/Func.pm:    $x1->{at} = [@_];
lib/Rstats/Func.pm:  return $x1->{at};
lib/Rstats/Func.pm:  my $e1_name = $x1_index->value;
lib/Rstats/Func.pm:  my $names = $x1->names->values;
lib/Rstats/Func.pm:    my $name = $names->[$i];
lib/Rstats/Func.pm:  return Rstats::ArrayFunc::c(Rstats::Func::levels(undef(), $x1)->length_value);
lib/Rstats/Func.pm:  if (exists $x1->{vector}) {
lib/Rstats/Func.pm:    $length = $x1->vector->length_value;
lib/Rstats/Func.pm:    $length = @{$x1->list}
lib/Rstats/Func.pm:  my $x2_values = [map { !defined $_ ? 1 : 0 } @{$x1->values}];
lib/Rstats/Func.pm:  $x2->vector(Rstats::VectorFunc::new_logical(@$x2_values));
lib/Rstats/Func.pm:  if (exists $x1->{list}) {
lib/Rstats/Func.pm:    my $list = Rstats::List->new;
lib/Rstats/Func.pm:    $x2->vector($x1->vector->clone);
lib/Rstats/Func.pm:    $list->list([$x2]);
lib/Rstats/Func.pm:  return exists $x1->{list} ? Rstats::Func::TRUE() : Rstats::Func::FALSE();
lib/Rstats/Func.pm:    $x1->{class} = $x_class->vector;
lib/Rstats/Func.pm:    if (exists $x1->{class}) {
lib/Rstats/Func.pm:      $x_class->vector($x1->{class}->clone);
lib/Rstats/Func.pm:      $x_class->vector($x1->mode->vector->clone);
lib/Rstats/Func.pm:      $x_class->vector(Rstats::VectorFunc::new_character('matrix'));
lib/Rstats/Func.pm:      $x_class->vector(Rstats::VectorFunc::new_character('array'));
lib/Rstats/Func.pm:      $x_class->vector(Rstats::VectorFunc::new_character('data.frame'));
lib/Rstats/Func.pm:      $x_class->vector(Rstats::VectorFunc::new_character('list'));
lib/Rstats/Func.pm:  if (exists $x1->{dim}) {
lib/Rstats/Func.pm:    return $x1->dim;
lib/Rstats/Func.pm:    my $length = $x1->length_value;
lib/Rstats/Func.pm:    my $x1_length = $x1->length_value;
lib/Rstats/Func.pm:    $x1_lenght_by_dim *= $_ for @{$x_dim->values};
lib/Rstats/Func.pm:    $x1->{dim} = $x_dim->vector->clone;
lib/Rstats/Func.pm:    if (defined $x1->{dim}) {
lib/Rstats/Func.pm:      $x_dim->vector($x1->{dim}->clone);
lib/Rstats/Func.pm:    $x1->vector($x1->vector->as($type));
lib/Rstats/Func.pm:    my $type = $x1->vector->type;
lib/Rstats/Func.pm:    my $type = $x1->vector->type;
lib/Rstats/Func.pm:  return shift->vector->type;
lib/Rstats/Func.pm:  my $classes = $x1->class->values;
lib/Rstats/Func.pm:  my $classes = $x1->class->values;
lib/Rstats/Func.pm:  my $x1_dim_elements = $x1->dim_as_array->values;
lib/Rstats/Func.pm:    $row = $x1_dim_elements->[0];
lib/Rstats/Func.pm:    $col = $x1_dim_elements->[1];
lib/Rstats/Func.pm:  my $x2_vector = $x1->vector->clone;
lib/Rstats/Func.pm:  $x2->vector($x2_vector);
lib/Rstats/Func.pm:  my $x2_vector = $x1->vector->clone;
lib/Rstats/Func.pm:  $x2->vector($x2_vector);
lib/Rstats/Func.pm:  my $x1_dim_elements = [@{$x1->dim_as_array->values}];
lib/Rstats/Func.pm:  return $x1->array($x2, $x1_dim_elements);
lib/Rstats/Func.pm:  my $x2_vector = $x1->vector->clone;
lib/Rstats/Func.pm:  $x2->vector($x2_vector);
lib/Rstats/Func.pm:  $x2 = Rstats::Array->new->vector($x_tmp->vector->as_complex);
lib/Rstats/Func.pm:  $x_tmp->copy_attrs_to($x2);
lib/Rstats/Func.pm:    $x2 = Rstats::Array->new->vector($x1->vector->as_double);
lib/Rstats/Func.pm:    $x2 = Rstats::Array->new->vector($x1->vector->as_double);
lib/Rstats/Func.pm:    $x1->copy_attrs_to($x2);
lib/Rstats/Func.pm:    $x2 = Rstats::Array->new->vector($x1->vector->as_integer);
lib/Rstats/Func.pm:    $x2 = Rstats::Array->new->vector($x1->vector->as_integer);
lib/Rstats/Func.pm:    $x1->copy_attrs_to($x2);
lib/Rstats/Func.pm:    $x2 = Rstats::Array->new->vector($x1->vector->as_logical);
lib/Rstats/Func.pm:    $x2 = Rstats::Array->new->vector($x1->vector->as_logical);
lib/Rstats/Func.pm:    $x1->copy_attrs_to($x2);
lib/Rstats/Func.pm:  return $r->as_character(@_);
lib/Rstats/Func.pm:    my $x_levels_values = $x_levels->values;
lib/Rstats/Func.pm:    my $levels_length = $x_levels->length_value;
lib/Rstats/Func.pm:      $levels->{$i} = $x_levels_values->[$i - 1];
lib/Rstats/Func.pm:    my $x1_values = $x1->values;
lib/Rstats/Func.pm:        my $character = $levels->{$x1_value};
lib/Rstats/Func.pm:    $x2->vector(Rstats::VectorFunc::new_character(@$x2_values));
lib/Rstats/Func.pm:    $x1->copy_attrs_to($x2)
lib/Rstats/Func.pm:    $x2 = Rstats::Array->new->vector($x1->vector->as_character);
lib/Rstats/Func.pm:    $x1->copy_attrs_to($x2);
lib/Rstats/Func.pm:    $x1->vector(Rstats::ArrayFunc::c(@{$_[0]})->vector);
lib/Rstats/Func.pm:    my $values = $x1->vector->values;
lib/Rstats/Func.pm:  my $is = ref $x1 eq 'Rstats::Array' && !exists $x1->{dim};
lib/Rstats/Func.pm:  my $x_is = ref $x1 eq 'Rstats::Array' && $x1->dim->length_value == 2
lib/Rstats/Func.pm:  my $x_is = (is_array(undef(), $x1) || Rstats::Func::is_vector(undef(), $x1)) && (($x1->vector->type || '') eq 'double' || ($x1->vector->type || '') eq 'integer')
lib/Rstats/Func.pm:  my $x_is = (is_array(undef(), $x1) || Rstats::Func::is_vector(undef(), $x1)) && ($x1->vector->type || '') eq 'double'
lib/Rstats/Func.pm:  my $x_is = (is_array(undef(), $x1) || Rstats::Func::is_vector(undef(), $x1)) && ($x1->vector->type || '') eq 'integer'
lib/Rstats/Func.pm:  my $x_is = (is_array(undef(), $x1) || Rstats::Func::is_vector(undef(), $x1)) && ($x1->vector->type || '') eq 'complex'
lib/Rstats/Func.pm:  my $x_is = (is_array(undef(), $x1) || Rstats::Func::is_vector(undef(), $x1)) && ($x1->vector->type || '') eq 'character'
lib/Rstats/Func.pm:  my $x_is = (is_array(undef(), $x1) || Rstats::Func::is_vector(undef(), $x1)) && ($x1->vector->type || '') eq 'logical'
lib/Rstats/Func.pm:  my $is = ref $x1 eq 'Rstats::Array' && exists $x1->{dim};
lib/Rstats/Func.pm:    $x1->{names} = $names->vector->clone;
lib/Rstats/Func.pm:      $x1->{dimnames}[1] = $x1->{names}->vector->clone;
lib/Rstats/Func.pm:    if (exists $x1->{names}) {
lib/Rstats/Func.pm:      $x_names->vector($x1->{names}->clone);
lib/Rstats/Func.pm:      my $length = $dimnames_list->length_value;
lib/Rstats/Func.pm:        my $x_dimname = $dimnames_list->getin($i + 1);
lib/Rstats/Func.pm:          my $dimname = $x_dimname->vector->clone;
lib/Rstats/Func.pm:      $x1->{dimnames} = $dimnames;
lib/Rstats/Func.pm:        $x1->{names} = $x1->{dimnames}[1]->clone;
lib/Rstats/Func.pm:    if (exists $x1->{dimnames}) {
lib/Rstats/Func.pm:      $x_dimnames->list($x1->{dimnames});
lib/Rstats/Func.pm:    unless (exists $x1->{dimnames}) {
lib/Rstats/Func.pm:      $x1->{dimnames} = [];
lib/Rstats/Func.pm:    $x1->{dimnames}[0] = $x_rownames->vector->clone;
lib/Rstats/Func.pm:    if (defined $x1->{dimnames}[0]) {
lib/Rstats/Func.pm:      $x_rownames->vector($x1->{dimnames}[0]->clone);
lib/Rstats/Func.pm:    unless (exists $x1->{dimnames}) {
lib/Rstats/Func.pm:      $x1->{dimnames} = [];
lib/Rstats/Func.pm:    $x1->{dimnames}[1] = $x_colnames->vector->clone;
lib/Rstats/Func.pm:    if (defined $x1->{dimnames}[1]) {
lib/Rstats/Func.pm:      $x_colnames->vector($x1->{dimnames}[1]->clone);
lib/Rstats/Func.pm:Rstats::Func - Functions
lib/Rstats/Util.pm:  if ($type_level->{$type1} > $type_level->{$type2}) {
lib/Rstats/Util.pm:  my $x1_dim = $x1->dim_as_array->values;
lib/Rstats/Util.pm:    && Rstats::Func::is_logical(undef(), $_indexs[0]) && $_indexs[0]->dim->length_value > 1) {
lib/Rstats/Util.pm:    my $x2_dim_values = $x2->dim->values;
lib/Rstats/Util.pm:    my $x2_values = $x2->values;
lib/Rstats/Util.pm:      next unless $x2_values->[$i];
lib/Rstats/Util.pm:      my $index_values = $index->values;
lib/Rstats/Util.pm:        $index->{_minus} = 1 if $minus_count > 0;
lib/Rstats/Util.pm:      if (!@{$index->values}) {
lib/Rstats/Util.pm:        my $index_values_new = [1 .. $x1_dim->[$i]];
lib/Rstats/Util.pm:          for my $name (@{$index->values}) {
lib/Rstats/Util.pm:            for my $x1_name (@{$x1->names->values}) {
lib/Rstats/Util.pm:                $value = $x1->values->[$i];
lib/Rstats/Util.pm:        for (my $i = 0; $i < @{$index->values}; $i++) {
lib/Rstats/Util.pm:          push @$index_values_new, $i + 1 if $index_values->[$i];
lib/Rstats/Util.pm:      elsif ($index->{_minus}) {
lib/Rstats/Util.pm:        for my $k (1 .. $x1_dim->[$i]) {
lib/Rstats/Util.pm:          push @$index_value_new, $k unless grep { $_ == -$k } @{$index->values};
lib/Rstats/Util.pm:      my $count = $index->vector->length_value;
lib/Rstats/Util.pm:    my $index_values = [map { $_->values } @indexs];
lib/Rstats/Util.pm:Rstats::Util - Utility class
lib/Rstats/Array.pm:use Rstats::Container -base;
lib/Rstats/Array.pm:  '-' => sub { Rstats::ArrayFunc::subtract(Rstats::ArrayFunc::_fix_pos(@_)) },
lib/Rstats/Array.pm:Rstats::Array - Array
lib/Rstats/ArrayFunc.pm:  my $x1 = Rstats::Array->new;
lib/Rstats/ArrayFunc.pm:  $x1->vector(Rstats::Vector->new_null);
lib/Rstats/ArrayFunc.pm:  return $r->FALSE;
lib/Rstats/ArrayFunc.pm:  $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  $x2->class('AsIs');
lib/Rstats/ArrayFunc.pm:  my $x2 = $x1->get($x_condition, $x_names);
lib/Rstats/ArrayFunc.pm:  my $x1_row = $x1->dim->values->[0];
lib/Rstats/ArrayFunc.pm:  my $x1_col = $x1->dim->values->[1];
lib/Rstats/ArrayFunc.pm:      my $value = $x1->value($row, $col);
lib/Rstats/ArrayFunc.pm:      $x2->at($col, $row);
lib/Rstats/ArrayFunc.pm:      $x2->set($value);
lib/Rstats/ArrayFunc.pm:  my $new_names = $x1->names->values;
lib/Rstats/ArrayFunc.pm:  my $new_elements = $x1->list;
lib/Rstats/ArrayFunc.pm:  my $names = $x1->names->values;
lib/Rstats/ArrayFunc.pm:    my $found_pos = -1;
lib/Rstats/ArrayFunc.pm:      my $name = $names->[$i];
lib/Rstats/ArrayFunc.pm:    if ($found_pos == -1) {
lib/Rstats/ArrayFunc.pm:      $new_elements->[$found_pos] = $new_v;
lib/Rstats/ArrayFunc.pm:    push @new_args, $new_names->[$i], $new_elements->[$i];
lib/Rstats/ArrayFunc.pm:  for my $v (@{$x1->list}) {
lib/Rstats/ArrayFunc.pm:    for (my $index = 1; $index <= $x1->{row_length}; $index++) {
lib/Rstats/ArrayFunc.pm:      push @poss, $index unless defined $v->value($index);
lib/Rstats/ArrayFunc.pm:  my $x2 = $x1->get(-(c(@poss)), NULL);
lib/Rstats/ArrayFunc.pm:  $x_by = $x1->names->get(1) unless defined $x_by;
lib/Rstats/ArrayFunc.pm:  my $by_x = $x_by_x->value;
lib/Rstats/ArrayFunc.pm:  my $by_y = $x_by_y->value;
lib/Rstats/ArrayFunc.pm:  my $sort = defined $x_sort ? $x_sort->value : 0;
lib/Rstats/ArrayFunc.pm:#           na.strings = "NA", colClasses = NA, nrows = -1,
lib/Rstats/ArrayFunc.pm:  my $file = $x_file->value;
lib/Rstats/ArrayFunc.pm:  my $sep = defined $x_sep ? $x_sep->value : "\\s+";
lib/Rstats/ArrayFunc.pm:  my $encoding = defined $x_encoding ? $x_encoding->value : 'UTF-8';
lib/Rstats/ArrayFunc.pm:  my $skip = defined $x_skip ? $x_skip->value : 0;
lib/Rstats/ArrayFunc.pm:  my $header_opt = defined $x_header ? $x_header->value : 0;
lib/Rstats/ArrayFunc.pm:      $skip--;
lib/Rstats/ArrayFunc.pm:      $columns->[$i] ||= [];
lib/Rstats/ArrayFunc.pm:      push @{$columns->[$i]}, $row[$i];
lib/Rstats/ArrayFunc.pm:      $type_columns->[$i] = Rstats::Util::higher_type($type_columns->[$i], $type);
lib/Rstats/ArrayFunc.pm:    if (defined $header->[$i]) {
lib/Rstats/ArrayFunc.pm:      push @$data_frame_args, $header->[$i];
lib/Rstats/ArrayFunc.pm:    my $type = $type_columns->[$i];
lib/Rstats/ArrayFunc.pm:      my $x1 = Rstats::ArrayFunc::c(@{$columns->[$i]});
lib/Rstats/ArrayFunc.pm:      my $x1 = Rstats::ArrayFunc::c(@{$columns->[$i]});
lib/Rstats/ArrayFunc.pm:      my $x1 = Rstats::ArrayFunc::c(@{$columns->[$i]});
lib/Rstats/ArrayFunc.pm:      my $x1 = Rstats::ArrayFunc::c(@{$columns->[$i]});
lib/Rstats/ArrayFunc.pm:      my $x1 = Rstats::ArrayFunc::c(@{$columns->[$i]});
lib/Rstats/ArrayFunc.pm:  $opt = ref $_[-1] eq 'HASH' ? pop : {};
lib/Rstats/ArrayFunc.pm:  my $sep = $x_sep->value;
lib/Rstats/ArrayFunc.pm:    my $length = $x->length->value;
lib/Rstats/ArrayFunc.pm:      my $length = $fix_x->length_value;
lib/Rstats/ArrayFunc.pm:      push @$chars, $fix_x->value(($i % $length) + 1)
lib/Rstats/ArrayFunc.pm:      push @$levels, Rstats::Func::levels(undef(), $x)->values;
lib/Rstats/ArrayFunc.pm:  my $n = $x_n->value;
lib/Rstats/ArrayFunc.pm:  my $k = $x_k->value;
lib/Rstats/ArrayFunc.pm:  my $length = $x_length->value;
lib/Rstats/ArrayFunc.pm:  my $levels = $x_levels->values;
lib/Rstats/ArrayFunc.pm:  my $opt = ref $_[-1] eq 'HASH' ? pop : {};
lib/Rstats/ArrayFunc.pm:  $opt->{ordered} = Rstats::ArrayFunc::TRUE();
lib/Rstats/ArrayFunc.pm:  # default - x
lib/Rstats/ArrayFunc.pm:  # default - levels
lib/Rstats/ArrayFunc.pm:  # default - exclude
lib/Rstats/ArrayFunc.pm:  if (defined $x_exclude->value && $x_exclude->length->value) {
lib/Rstats/ArrayFunc.pm:    for my $x_levels_value (@{$x_levels->values}) {
lib/Rstats/ArrayFunc.pm:      for my $x_exclude_value (@{$x_exclude->values}) {
lib/Rstats/ArrayFunc.pm:  # default - labels
lib/Rstats/ArrayFunc.pm:  # default - ordered
lib/Rstats/ArrayFunc.pm:  my $x1_values = $x1->values;
lib/Rstats/ArrayFunc.pm:  my $labels_length = $x_labels->length->value;
lib/Rstats/ArrayFunc.pm:  my $levels_length = $x_levels->length->value;
lib/Rstats/ArrayFunc.pm:  if ($labels_length == 1 && $x1->length_value != 1) {
lib/Rstats/ArrayFunc.pm:    my $value = $x_labels->value;
lib/Rstats/ArrayFunc.pm:  my $x_levels_values = $x_levels->values;
lib/Rstats/ArrayFunc.pm:    my $x_levels_value = $x_levels_values->[$i - 1];
lib/Rstats/ArrayFunc.pm:    $levels->{$x_levels_value} = $i;
lib/Rstats/ArrayFunc.pm:      my $f1_value = exists $levels->{$x1_value}
lib/Rstats/ArrayFunc.pm:        ? $levels->{$x1_value}
lib/Rstats/ArrayFunc.pm:    $f1->{class} = Rstats::VectorFunc::new_character('factor', 'ordered');
lib/Rstats/ArrayFunc.pm:    $f1->{class} = Rstats::VectorFunc::new_character('factor');
lib/Rstats/ArrayFunc.pm:  $f1->{levels} = $x_labels->vector->clone;
lib/Rstats/ArrayFunc.pm:    return c($container->vector->length_value);
lib/Rstats/ArrayFunc.pm:  my $list = Rstats::List->new;
lib/Rstats/ArrayFunc.pm:  $list->list(\@elements);
lib/Rstats/ArrayFunc.pm:    if (Rstats::Func::is_character(undef(), $v) && !grep {$_ eq 'AsIs'} @{$v->class->values}) {
lib/Rstats/ArrayFunc.pm:    my $dim_values = $v->dim->values;
lib/Rstats/ArrayFunc.pm:      my $count = $dim_values->[0];
lib/Rstats/ArrayFunc.pm:      $dim_product *= $dim_values->[$_] for (1 .. @$dim_values - 1);
lib/Rstats/ArrayFunc.pm:        if (my $count = $name_count->{$name}) {
lib/Rstats/ArrayFunc.pm:        push @$elements, splice(@{$v->values}, 0, $count);
lib/Rstats/ArrayFunc.pm:      my $count = $v->length_value;
lib/Rstats/ArrayFunc.pm:      if (my $count = $name_count->{$name}) {
lib/Rstats/ArrayFunc.pm:    $name_count->{$name}++;
lib/Rstats/ArrayFunc.pm:    my $count = $counts->[$i];
lib/Rstats/ArrayFunc.pm:      push @$repeat_elements, $elements->[$i] for (1 .. $repeat);
lib/Rstats/ArrayFunc.pm:      $elements->[$i] = Rstats::ArrayFunc::c(@$repeat_elements);
lib/Rstats/ArrayFunc.pm:  my $data_frame = Rstats::DataFrame->new;
lib/Rstats/ArrayFunc.pm:  $data_frame->{row_length} = $max_count;
lib/Rstats/ArrayFunc.pm:  $data_frame->list($elements);
lib/Rstats/ArrayFunc.pm:  $data_frame->dimnames(
lib/Rstats/ArrayFunc.pm:  my $diag = defined $x1_diag ? $x1_diag->value : 0;
lib/Rstats/ArrayFunc.pm:    my $x1_dim_values = $x1_m->dim->values;
lib/Rstats/ArrayFunc.pm:    my $rows_count = $x1_dim_values->[0];
lib/Rstats/ArrayFunc.pm:    my $cols_count = $x1_dim_values->[1];
lib/Rstats/ArrayFunc.pm:  my $diag = defined $x1_diag ? $x1_diag->value : 0;
lib/Rstats/ArrayFunc.pm:    my $x1_dim_values = $x1_m->dim->values;
lib/Rstats/ArrayFunc.pm:    my $rows_count = $x1_dim_values->[0];
lib/Rstats/ArrayFunc.pm:    my $cols_count = $x1_dim_values->[1];
lib/Rstats/ArrayFunc.pm:  if ($x1->length_value == 1) {
lib/Rstats/ArrayFunc.pm:    $size = $x1->value;
lib/Rstats/ArrayFunc.pm:    $size = $x1->length_value;
lib/Rstats/ArrayFunc.pm:    $x2_values = $x1->values;
lib/Rstats/ArrayFunc.pm:    $x2->at($i + 1, $i + 1);
lib/Rstats/ArrayFunc.pm:    $x2->set($x2_values->[$i]);
lib/Rstats/ArrayFunc.pm:  my $x1_dim_values = $x1->dim->values;
lib/Rstats/ArrayFunc.pm:  my $size = $x1_dim_values->[0] < $x1_dim_values->[1] ? $x1_dim_values->[0] : $x1_dim_values->[1];
lib/Rstats/ArrayFunc.pm:  my $x2_values = $x2->values;
lib/Rstats/ArrayFunc.pm:    $x1->at($i + 1, $i + 1);
lib/Rstats/ArrayFunc.pm:    $x1->set($x2_values->[$i]);
lib/Rstats/ArrayFunc.pm:  ($x1, $x2) = Rstats::ArrayFunc::upgrade_type($x1, $x2) if $x1->type ne $x2->type;
lib/Rstats/ArrayFunc.pm:  my $x1_dim = $x1->dim;
lib/Rstats/ArrayFunc.pm:  my $x2_dim = $x2->dim;
lib/Rstats/ArrayFunc.pm:    = $x1_dim->length_value > $x2_dim->length_value ? $x1_dim->length_value : $x2_dim->length_value;
lib/Rstats/ArrayFunc.pm:  my $x1_dim_values = $x1_dim->values;
lib/Rstats/ArrayFunc.pm:  my $x2_dim_values = $x2_dim->values;
lib/Rstats/ArrayFunc.pm:    my $x1_dim_value = $x1_dim_values->[$i] || 1;
lib/Rstats/ArrayFunc.pm:    my $x2_dim_value = $x2_dim_values->[$i] || 1;
lib/Rstats/ArrayFunc.pm:      my $x3_i = $x3_index->[$k];
lib/Rstats/ArrayFunc.pm:      my $x1_dim_value = $x1_dim_values->[$k] || 1;
lib/Rstats/ArrayFunc.pm:      my $x2_dim_value = $x2_dim_values->[$k] || 1;
lib/Rstats/ArrayFunc.pm:      my $x1_ind = int(($x3_i - 1)/$x2_dim_value) + 1;
lib/Rstats/ArrayFunc.pm:      my $x2_ind = $x3_i - $x2_dim_value * ($x1_ind - 1);
lib/Rstats/ArrayFunc.pm:    my $x1_value = $x1->value(@$x1_index);
lib/Rstats/ArrayFunc.pm:    my $x2_value = $x2->value(@$x2_index);
lib/Rstats/ArrayFunc.pm:  ($x1, $x2) = Rstats::ArrayFunc::upgrade_type($x1, $x2) if $x1->type ne $x2->type;
lib/Rstats/ArrayFunc.pm:  my $x1_dim = $x1->dim;
lib/Rstats/ArrayFunc.pm:  my $x2_dim = $x2->dim;
lib/Rstats/ArrayFunc.pm:  my $x3_dim = [@{$x1_dim->values}, @{$x2_dim->values}];
lib/Rstats/ArrayFunc.pm:  my $x1_dim_length = $x1_dim->length_value;
lib/Rstats/ArrayFunc.pm:    my $x1_value = $x1->value(@$x1_pos);
lib/Rstats/ArrayFunc.pm:    my $x2_value = $x2->value(@$x2_pos);
lib/Rstats/ArrayFunc.pm:  my $pattern = $x1_pattern->value;
lib/Rstats/ArrayFunc.pm:  my $replacement = $x1_replacement->value;
lib/Rstats/ArrayFunc.pm:  my $ignore_case = defined $x1_ignore_case ? $x1_ignore_case->value : 0;
lib/Rstats/ArrayFunc.pm:  for my $x (@{$x1_x->values}) {
lib/Rstats/ArrayFunc.pm:  $x1_x->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  my $pattern = $x1_pattern->value;
lib/Rstats/ArrayFunc.pm:  my $replacement = $x1_replacement->value;
lib/Rstats/ArrayFunc.pm:  my $ignore_case = defined $x1_ignore_case ? $x1_ignore_case->value : 0;
lib/Rstats/ArrayFunc.pm:  for my $x (@{$x1_x->values}) {
lib/Rstats/ArrayFunc.pm:  $x1_x->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  my $pattern = $x1_pattern->value;
lib/Rstats/ArrayFunc.pm:  my $ignore_case = defined $x1_ignore_case ? $x1_ignore_case->value : 0;
lib/Rstats/ArrayFunc.pm:  my $x1_x_values = $x1_x->values;
lib/Rstats/ArrayFunc.pm:    my $x = $x1_x_values->[$i];
lib/Rstats/ArrayFunc.pm:  my $nrow = nrow(undef(), $x1)->value;
lib/Rstats/ArrayFunc.pm:  my $ncol = ncol(undef(), $x1)->value;
lib/Rstats/ArrayFunc.pm:  my $old = $x1_old->value;
lib/Rstats/ArrayFunc.pm:  my $new = $x1_new->value;
lib/Rstats/ArrayFunc.pm:  for my $x (@{$x1_x->values}) {
lib/Rstats/ArrayFunc.pm:  $x1_x->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:    unless $x1_x->vector->type eq 'character' && $x1_table->vector->type eq 'character';
lib/Rstats/ArrayFunc.pm:  for my $x1_x_value (@{$x1_x->values}) {
lib/Rstats/ArrayFunc.pm:    my $x1_table_values = $x1_table->values;
lib/Rstats/ArrayFunc.pm:    for (my $k = 0; $k < $x1_table->length_value; $k++) {
lib/Rstats/ArrayFunc.pm:      my $x1_table_char = $x1_table_values->[$k];
lib/Rstats/ArrayFunc.pm:    return Rstats::ArrayFunc::c($x1->{row_length});
lib/Rstats/ArrayFunc.pm:    return Rstats::ArrayFunc::c($x1->dim->values->[0]);
lib/Rstats/ArrayFunc.pm:  Carp::croak "mode is diffrence" if $x1->vector->type ne $x2->vector->type;
lib/Rstats/ArrayFunc.pm:  my $type = $x1->type;
lib/Rstats/ArrayFunc.pm:  my $x1_values = $x1->values;
lib/Rstats/ArrayFunc.pm:  my $x2_values = $x2->values;
lib/Rstats/ArrayFunc.pm:        if ($x1_value->{re} == $x2_value->{re} && $x1_value->{im} == $x2_value->{im}) {
lib/Rstats/ArrayFunc.pm:  Carp::croak "mode is diffrence" if $x1->vector->type ne $x2->vector->type;
lib/Rstats/ArrayFunc.pm:  return FALSE if $x3->length_value ne $x4->length_value;
lib/Rstats/ArrayFunc.pm:  my $x3_elements = $x3->decompose;
lib/Rstats/ArrayFunc.pm:  my $x4_elements = $x4->decompose;
lib/Rstats/ArrayFunc.pm:  for (my $i = 0; $i < $x3->length_value; $i++) {
lib/Rstats/ArrayFunc.pm:    unless (Rstats::VectorFunc::equal($x3_elements->[$i], $x4_elements->[$i])->value) {
lib/Rstats/ArrayFunc.pm:  Carp::croak "mode is diffrence" if $x1->vector->type ne $x2->vector->type;
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:  my $x2_elements = $x2->decompose;
lib/Rstats/ArrayFunc.pm:      if (Rstats::VectorFunc::equal($x1_element, $x2_element)->value) {
lib/Rstats/ArrayFunc.pm:  Carp::croak "mode is diffrence" if $x1->vector->type ne $x2->vector->type;
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:  my $x2_elements = $x2->decompose;
lib/Rstats/ArrayFunc.pm:      if (Rstats::VectorFunc::equal($x1_element, $x2_element)->value) {
lib/Rstats/ArrayFunc.pm:  Carp::croak "mode is diffrence" if $x1->vector->type ne $x2->vector->type;
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:  for (my $i = 0; $i < $x1->length_value - 1; $i++) {
lib/Rstats/ArrayFunc.pm:    my $x1_element1 = $x1_elements->[$i];
lib/Rstats/ArrayFunc.pm:    my $x1_element2 = $x1_elements->[$i + 1];
lib/Rstats/ArrayFunc.pm:  $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  if ($x1->vector->type eq 'character') {
lib/Rstats/ArrayFunc.pm:    for my $x1_element (@{$x1->decompose}) {
lib/Rstats/ArrayFunc.pm:      if (Rstats::Func::is_na(undef(), $x1_element)->value) {
lib/Rstats/ArrayFunc.pm:        my $x2_element = Rstats::VectorFunc::new_double(CORE::length $x1_element->value);
lib/Rstats/ArrayFunc.pm:    $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  if ($x1->vector->type eq 'character') {
lib/Rstats/ArrayFunc.pm:    for my $x1_element (@{$x1->decompose}) {
lib/Rstats/ArrayFunc.pm:      if (Rstats::Func::is_na(undef(), $x1_element)->value) {
lib/Rstats/ArrayFunc.pm:        my $x2_element = Rstats::VectorFunc::new_character(lc $x1_element->value);
lib/Rstats/ArrayFunc.pm:    $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  if ($x1->vector->type eq 'character') {
lib/Rstats/ArrayFunc.pm:    for my $x1_element (@{$x1->decompose}) {
lib/Rstats/ArrayFunc.pm:      if (Rstats::Func::is_na(undef(), $x1_element)->value) {
lib/Rstats/ArrayFunc.pm:        my $x2_element = Rstats::VectorFunc::new_character(uc $x1_element->value);
lib/Rstats/ArrayFunc.pm:    $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:  my $x2_elements = $x2->decompose;
lib/Rstats/ArrayFunc.pm:      if (Rstats::VectorFunc::equal($x1_element, $x2_element)->value) {
lib/Rstats/ArrayFunc.pm:  my $x1_length = $x1->length_value;
lib/Rstats/ArrayFunc.pm:  my $after = $x_after->value;
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:  my $x2_elements = $x2->decompose;
lib/Rstats/ArrayFunc.pm:        $different = 1 if $x->{row_length} != $first_row_length;
lib/Rstats/ArrayFunc.pm:        $first_row_length = $x->{row_length};
lib/Rstats/ArrayFunc.pm:      my $names = $x->names->values;
lib/Rstats/ArrayFunc.pm:        push @data_frame_args, $name, $x->getin($name);
lib/Rstats/ArrayFunc.pm:      my $a1_dim_elements = $a1->dim->decompose;
lib/Rstats/ArrayFunc.pm:        $row_count = $a1_dim_elements->[0];
lib/Rstats/ArrayFunc.pm:        $col_count_total += $a1_dim_elements->[1];
lib/Rstats/ArrayFunc.pm:        $row_count = $a1->dim_as_array->values->[0];
lib/Rstats/ArrayFunc.pm:      push @$x2_elements, @{$a1->decompose};
lib/Rstats/ArrayFunc.pm:  my @a2_elements = map { Rstats::VectorFunc::new_double(POSIX::ceil $_->value) } @{$x1->decompose};
lib/Rstats/ArrayFunc.pm:  $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  $x2->mode('double');
lib/Rstats/ArrayFunc.pm:  my $dim_values = $x1->dim->values;
lib/Rstats/ArrayFunc.pm:    for my $row (1 .. $dim_values->[0]) {
lib/Rstats/ArrayFunc.pm:      $x1_value += $x1->value($row, $_) for (1 .. $dim_values->[1]);
lib/Rstats/ArrayFunc.pm:      push @$x1_values, $x1_value / $dim_values->[1];
lib/Rstats/ArrayFunc.pm:  my $dim_values = $x1->dim->values;
lib/Rstats/ArrayFunc.pm:    for my $row (1 .. $dim_values->[0]) {
lib/Rstats/ArrayFunc.pm:      $x1_value += $x1->value($row, $_) for (1 .. $dim_values->[1]);
lib/Rstats/ArrayFunc.pm:  unless ($x1->length_value) {
lib/Rstats/ArrayFunc.pm:    Carp::carp 'no non-missing arguments to max; returning -Inf';
lib/Rstats/ArrayFunc.pm:    return -(Rstats::ArrayFunc::Inf());
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:    if (Rstats::Func::is_na(undef(), $element)->value) {
lib/Rstats/ArrayFunc.pm:    elsif (Rstats::Func::is_nan(undef(), $element)->value) {
lib/Rstats/ArrayFunc.pm:    if (Rstats::VectorFunc::more_than($element, $max)->value && !Rstats::Func::is_nan(undef(), $max)->value) {
lib/Rstats/ArrayFunc.pm:  unless ($x1->length_value) {
lib/Rstats/ArrayFunc.pm:    Carp::carp 'no non-missing arguments to max; returning -Inf';
lib/Rstats/ArrayFunc.pm:    return -(Rstats::ArrayFunc::Inf());
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:    if (Rstats::Func::is_na(undef(), $element)->value) {
lib/Rstats/ArrayFunc.pm:    elsif (Rstats::Func::is_nan(undef(), $element)->value) {
lib/Rstats/ArrayFunc.pm:    if (Rstats::VectorFunc::less_than($element, $min)->value && !Rstats::Func::is_nan(undef(), $min)->value) {
lib/Rstats/ArrayFunc.pm:  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
lib/Rstats/ArrayFunc.pm:    my $name = $names->[$i];
lib/Rstats/ArrayFunc.pm:    if (exists $opt->{$name}) {
lib/Rstats/ArrayFunc.pm:      $arg = to_c(delete $opt->{$name});
lib/Rstats/ArrayFunc.pm:  if ($x1_mod->length_value || $x1_arg->length_value) {
lib/Rstats/ArrayFunc.pm:    my $x1_mod_length = $x1_mod->length_value;
lib/Rstats/ArrayFunc.pm:    my $x1_arg_length = $x1_arg->length_value;
lib/Rstats/ArrayFunc.pm:    my $x1_mod_elements = $x1_mod->decompose;
lib/Rstats/ArrayFunc.pm:    my $x1_arg_elements = $x1_arg->decompose;
lib/Rstats/ArrayFunc.pm:      my $mod = $x1_mod_elements->[$i];
lib/Rstats/ArrayFunc.pm:      my $arg = $x1_arg_elements->[$i];
lib/Rstats/ArrayFunc.pm:    my $x1_re_elements = $x1_re->decompose;
lib/Rstats/ArrayFunc.pm:    my $x1_im_elements = $x1_im->decompose;
lib/Rstats/ArrayFunc.pm:    for (my $i = 0; $i <  $x1_im->length_value; $i++) {
lib/Rstats/ArrayFunc.pm:      my $re = $x1_re_elements->[$i] || Rstats::VectorFunc::new_double(0);
lib/Rstats/ArrayFunc.pm:      my $im = $x1_im_elements->[$i];
lib/Rstats/ArrayFunc.pm:    my $x_type = $x->typeof->value;
lib/Rstats/ArrayFunc.pm:    $type_h->{$x_type}++;
lib/Rstats/ArrayFunc.pm:      my $type = $x->type;
lib/Rstats/ArrayFunc.pm:      $type_h->{$type}++;
lib/Rstats/ArrayFunc.pm:  if ($type_h->{character}) {
lib/Rstats/ArrayFunc.pm:  elsif ($type_h->{complex}) {
lib/Rstats/ArrayFunc.pm:  elsif ($type_h->{double}) {
lib/Rstats/ArrayFunc.pm:  elsif ($type_h->{integer}) {
lib/Rstats/ArrayFunc.pm:  my @a2_elements = map { Rstats::VectorFunc::new_double(POSIX::floor $_->value) } @{$x1->decompose};
lib/Rstats/ArrayFunc.pm:  $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  $x2->mode('double');
lib/Rstats/ArrayFunc.pm:  my $n = defined $x_n ? $x_n->value : 6;
lib/Rstats/ArrayFunc.pm:    my $max = $x1->{row_length} < $n ? $x1->{row_length} : $n;
lib/Rstats/ArrayFunc.pm:    my $x2 = $x1->get($x_range, Rstats::ArrayFunc::NULL());
lib/Rstats/ArrayFunc.pm:    my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:    my $max = $x1->length_value < $n ? $x1->length_value : $n;
lib/Rstats/ArrayFunc.pm:      push @x2_elements, $x1_elements->[$i];
lib/Rstats/ArrayFunc.pm:    $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  my $x1_values = $x1->values;
lib/Rstats/ArrayFunc.pm:  unless ($x1->length_value) {
lib/Rstats/ArrayFunc.pm:    Carp::carp 'no non-missing arguments to max; returning -Inf';
lib/Rstats/ArrayFunc.pm:    return -(Rstats::ArrayFunc::Inf());
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:    if (Rstats::Func::is_na(undef(), $element)->value) {
lib/Rstats/ArrayFunc.pm:    elsif (Rstats::Func::is_nan(undef(), $element)->value) {
lib/Rstats/ArrayFunc.pm:    if (!Rstats::Func::is_nan(undef(), $max)->value && Rstats::VectorFunc::more_than($element, $max)->value) {
lib/Rstats/ArrayFunc.pm:  my $x2 = divide(sum(undef(), $x1), $x1->length_value);
lib/Rstats/ArrayFunc.pm:  unless ($x1->length_value) {
lib/Rstats/ArrayFunc.pm:    Carp::carp 'no non-missing arguments to min; returning -Inf';
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:    if (Rstats::Func::is_na(undef(), $element)->value) {
lib/Rstats/ArrayFunc.pm:    elsif (Rstats::Func::is_nan(undef(), $element)->value) {
lib/Rstats/ArrayFunc.pm:    if (!Rstats::Func::is_nan(undef(), $min)->value && Rstats::VectorFunc::less_than($element, $min)->value) {
lib/Rstats/ArrayFunc.pm:  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
lib/Rstats/ArrayFunc.pm:    push @xs_values, $x->values;
lib/Rstats/ArrayFunc.pm:  my $decreasing = $opt->{decreasing} || FALSE;
lib/Rstats/ArrayFunc.pm:  for my $i (0 .. @{$xs_values[0]} - 1) {
lib/Rstats/ArrayFunc.pm:    $pos_val->{val} = [];
lib/Rstats/ArrayFunc.pm:    push @{$pos_val->{val}}, $xs_values[$_][$i] for (0 .. @xs_values);
lib/Rstats/ArrayFunc.pm:          $comp = $a->{val}[$i] <=> $b->{val}[$i];
lib/Rstats/ArrayFunc.pm:          $comp = $b->{val}[$i] <=> $a->{val}[$i];
lib/Rstats/ArrayFunc.pm:  my @orders = map { $_->{pos} } @sorted_pos_values;
lib/Rstats/ArrayFunc.pm:  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
lib/Rstats/ArrayFunc.pm:  my $decreasing = $opt->{decreasing};
lib/Rstats/ArrayFunc.pm:  my $x1_values = $x1->values;
lib/Rstats/ArrayFunc.pm:  push @pos_vals, {pos => $_ + 1, value => $x1_values->[$_]} for (0 .. @$x1_values - 1);
lib/Rstats/ArrayFunc.pm:  my @sorted_pos_values = sort { $a->{value} <=> $b->{value} } @pos_vals;
lib/Rstats/ArrayFunc.pm:    my $value = $sorted_pos_value->{value};
lib/Rstats/ArrayFunc.pm:    $element_info->{$value} ||= {};
lib/Rstats/ArrayFunc.pm:    $element_info->{$value}{rank_total} += $sorted_pos_value->{rank};
lib/Rstats/ArrayFunc.pm:    $element_info->{$value}{rank_count}++;
lib/Rstats/ArrayFunc.pm:    my $value = $sorted_pos_value->{value};
lib/Rstats/ArrayFunc.pm:    $sorted_pos_value->{rank_average}
lib/Rstats/ArrayFunc.pm:      = $element_info->{$value}{rank_total} / $element_info->{$value}{rank_count};
lib/Rstats/ArrayFunc.pm:  my @sorted_pos_values2 = sort { $a->{pos} <=> $b->{pos} } @sorted_pos_values;
lib/Rstats/ArrayFunc.pm:  my @rank = map { $_->{rank_average} } @sorted_pos_values2;
lib/Rstats/ArrayFunc.pm:  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
lib/Rstats/ArrayFunc.pm:  my $sep = $opt->{sep};
lib/Rstats/ArrayFunc.pm:  my $x1_values = $x1->values;
lib/Rstats/ArrayFunc.pm:    my $elements = $v->decompose;
lib/Rstats/ArrayFunc.pm:      $maxs[$i] = $elements->[$i]
lib/Rstats/ArrayFunc.pm:        if !defined $maxs[$i] || Rstats::VectorFunc::more_than($elements->[$i], $maxs[$i])->value
lib/Rstats/ArrayFunc.pm:    my $elements = $v->decompose;
lib/Rstats/ArrayFunc.pm:      $mins[$i] = $elements->[$i]
lib/Rstats/ArrayFunc.pm:        if !defined $mins[$i] || Rstats::VectorFunc::less_than($elements->[$i], $mins[$i])->value
lib/Rstats/ArrayFunc.pm:        my $names = $x->names->values;
lib/Rstats/ArrayFunc.pm:          $different = 1 if $names->[$i] ne $first_names->[$i];
lib/Rstats/ArrayFunc.pm:        $first_names = $x->names->values;
lib/Rstats/ArrayFunc.pm:        my $v = $x->getin($name);
lib/Rstats/ArrayFunc.pm:      push @data_frame_args, $first_names->[$i], $new_vectors[$i];
lib/Rstats/ArrayFunc.pm:  my $times = defined $x_times ? $x_times->value : 1;
lib/Rstats/ArrayFunc.pm:  push @$elements, @{$x1->decompose} for 1 .. $times;
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:  my $x2_elements = $x2->decompose;
lib/Rstats/ArrayFunc.pm:    my $x2_element_hash = $x2_element->to_string;
lib/Rstats/ArrayFunc.pm:    $x2_elements_h->{$x2_element_hash}++;
lib/Rstats/ArrayFunc.pm:      if $x2_elements_h->{$x2_element_hash} > 1;
lib/Rstats/ArrayFunc.pm:  my $v3_elements = $v3->decompose;
lib/Rstats/ArrayFunc.pm:    my $hash = Rstats::VectorFunc::new_double($i + 1)->to_string;
lib/Rstats/ArrayFunc.pm:    if ($x2_elements_h->{$hash}) {
lib/Rstats/ArrayFunc.pm:      push @$v4_elements, $v3_elements->[$replace_count % $v3_length];
lib/Rstats/ArrayFunc.pm:      push @$v4_elements, $x1_elements->[$i];
lib/Rstats/ArrayFunc.pm:  my @a2_elements = reverse @{$x1->decompose};
lib/Rstats/ArrayFunc.pm:  $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
lib/Rstats/ArrayFunc.pm:    my $rnorm = ($sd * sqrt(-2 * CORE::log($rand1))
lib/Rstats/ArrayFunc.pm:  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
lib/Rstats/ArrayFunc.pm:  $digits = $opt->{digits} unless defined $digits;
lib/Rstats/ArrayFunc.pm:  my @a2_elements = map { Rstats::VectorFunc::new_double(Math::Round::round_even($_->value * $ro) / $ro) } @{$x1->decompose};
lib/Rstats/ArrayFunc.pm:  $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  $x2->mode('double');
lib/Rstats/ArrayFunc.pm:  my $dim_values = $x1->dim->values;
lib/Rstats/ArrayFunc.pm:    for my $col (1 .. $dim_values->[1]) {
lib/Rstats/ArrayFunc.pm:      $x1_value += $x1->value($_, $col) for (1 .. $dim_values->[0]);
lib/Rstats/ArrayFunc.pm:      push @$x1_values, $x1_value / $dim_values->[0];
lib/Rstats/ArrayFunc.pm:  my $dim_values = $x1->dim->values;
lib/Rstats/ArrayFunc.pm:    for my $col (1 .. $dim_values->[1]) {
lib/Rstats/ArrayFunc.pm:      $x1_value += $x1->value($_, $col) for (1 .. $dim_values->[0]);
lib/Rstats/ArrayFunc.pm:  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
lib/Rstats/ArrayFunc.pm:  my $replace = $opt->{replace};
lib/Rstats/ArrayFunc.pm:  my $x1_length = $x1->length_value;
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:  for my $i (0 .. $length - 1) {
lib/Rstats/ArrayFunc.pm:  my $x1_values = $x1->values;
lib/Rstats/ArrayFunc.pm:    push @x2_values, @{seq(undef(), 1, $x1_value)->values};
lib/Rstats/ArrayFunc.pm:  my $decreasing = defined $x_decreasing ? $x_decreasing->value : 0;
lib/Rstats/ArrayFunc.pm:  my @a2_elements = grep { !Rstats::Func::is_na(undef(), $_)->value && !Rstats::Func::is_nan(undef(), $_)->value } @{$x1->decompose};
lib/Rstats/ArrayFunc.pm:    ? [reverse sort { Rstats::VectorFunc::more_than($a, $b)->value ? 1 : Rstats::VectorFunc::equal($a, $b)->value ? 0 : -1 } @a2_elements]
lib/Rstats/ArrayFunc.pm:    : [sort { Rstats::VectorFunc::more_than($a, $b)->value ? 1 : Rstats::VectorFunc::equal($a, $b)->value ? 0 : -1 } @a2_elements];
lib/Rstats/ArrayFunc.pm:  my $n = defined $x_n ? $x_n->value : 6;
lib/Rstats/ArrayFunc.pm:  my $e1 = $x1->decompose;
lib/Rstats/ArrayFunc.pm:  my $max = $x1->length_value < $n ? $x1->length_value : $n;
lib/Rstats/ArrayFunc.pm:    unshift @e2, $e1->[$x1->length_value - ($i  + 1)];
lib/Rstats/ArrayFunc.pm:  $x1->copy_attrs_to($x1);
lib/Rstats/ArrayFunc.pm:  my $x2_elements = $func->($x1->vector);
lib/Rstats/ArrayFunc.pm:  $x2->vector($x2_elements);
lib/Rstats/ArrayFunc.pm:  $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:    = map { Rstats::VectorFunc::new_double(int $_->value) } @{$x1->decompose};
lib/Rstats/ArrayFunc.pm:  $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  $x2->mode('double');
lib/Rstats/ArrayFunc.pm:    for my $x1_element (@{$x1->decompose}) {
lib/Rstats/ArrayFunc.pm:      if (Rstats::Func::is_na(undef(), $x1_element)->value) {
lib/Rstats/ArrayFunc.pm:        my $str = $x1_element->to_string;
lib/Rstats/ArrayFunc.pm:        unless ($elements_count->{$str}) {
lib/Rstats/ArrayFunc.pm:        $elements_count->{$str}++;
lib/Rstats/ArrayFunc.pm:  my $x3_length = $x3->length_value;
lib/Rstats/ArrayFunc.pm:    my $x4 = $x3->get($middle);
lib/Rstats/ArrayFunc.pm:    my $x5 = $x3->get($middle + 1);
lib/Rstats/ArrayFunc.pm:    return $x3->get($middle);
lib/Rstats/ArrayFunc.pm:  my $x3_length = $x3->length_value;
lib/Rstats/ArrayFunc.pm:  push @$quantile_elements , $x3->get(1);
lib/Rstats/ArrayFunc.pm:    my $x4 = $x3->get($first_quoter);
lib/Rstats/ArrayFunc.pm:    my $x5 = $x3->get($first_quoter + 1);
lib/Rstats/ArrayFunc.pm:    push @$quantile_elements, $x3->get($first_quoter);
lib/Rstats/ArrayFunc.pm:    my $x4 = $x3->get($middle);
lib/Rstats/ArrayFunc.pm:    my $x5 = $x3->get($middle + 1);
lib/Rstats/ArrayFunc.pm:    push @$quantile_elements, $x3->get($middle);
lib/Rstats/ArrayFunc.pm:    my $x4 = $x3->get($third_quoter);
lib/Rstats/ArrayFunc.pm:    my $x5 = $x3->get($third_quoter + 1);
lib/Rstats/ArrayFunc.pm:    push @$quantile_elements, $x3->get($third_quoter);
lib/Rstats/ArrayFunc.pm:  push @$quantile_elements , $x3->get($x3_length);
lib/Rstats/ArrayFunc.pm:  $x4->names(Rstats::ArrayFunc::c(qw/0%  25%  50%  75% 100%/));
lib/Rstats/ArrayFunc.pm:  my $var = sum(undef(), ($x1 - Rstats::ArrayFunc::mean(undef(), $x1)) ** 2) / ($x1->length_value - 1);
lib/Rstats/ArrayFunc.pm:  my $x1_values = $x1->values;
lib/Rstats/ArrayFunc.pm:    local $_ = $x1_values->[$i];
lib/Rstats/ArrayFunc.pm:    if ($cond_cb->($x1_values->[$i])) {
lib/Rstats/ArrayFunc.pm:  $x1->vector(Rstats::VectorFunc::new_character(@_));
lib/Rstats/ArrayFunc.pm:  $x1->vector(Rstats::VectorFunc::new_complex(@_));
lib/Rstats/ArrayFunc.pm:  $x1->vector(Rstats::VectorFunc::new_double(@_));
lib/Rstats/ArrayFunc.pm:  $x1->vector(Rstats::VectorFunc::new_integer(@_));
lib/Rstats/ArrayFunc.pm:  $x1->vector(Rstats::VectorFunc::new_logical(@_));
lib/Rstats/ArrayFunc.pm:  $nrow = $x_nrow->value if defined $x_nrow;
lib/Rstats/ArrayFunc.pm:  $ncol = $x_ncol->value if defined $x_ncol;
lib/Rstats/ArrayFunc.pm:  $byrow = $x_byrow->value if defined $x_byrow;
lib/Rstats/ArrayFunc.pm:  my $x1_values = $x1->values;
lib/Rstats/ArrayFunc.pm:  my $x1_length = $x1->length_value;
lib/Rstats/ArrayFunc.pm:  $x_matrix->vector(Rstats::VectorFunc::new_vector($x1->vector->type, @$x1_values));
lib/Rstats/ArrayFunc.pm:      Rstats::ArrayFunc::c($dim->[1], $dim->[0]),
lib/Rstats/ArrayFunc.pm:      if $x1->length_value == 0 || $x2->length_value == 0;
lib/Rstats/ArrayFunc.pm:    Carp::croak "Error in a x b : non-conformable arguments"
lib/Rstats/ArrayFunc.pm:      unless $x1->dim->values->[1] == $x2->dim->values->[0];
lib/Rstats/ArrayFunc.pm:    my $row_max = $x1->dim->values->[0];
lib/Rstats/ArrayFunc.pm:    my $col_max = $x2->dim->values->[1];
lib/Rstats/ArrayFunc.pm:        my $x1_part = $x1->get($row);
lib/Rstats/ArrayFunc.pm:        my $x2_part = $x2->get(Rstats::ArrayFunc::NULL(), $col);
lib/Rstats/ArrayFunc.pm:  my $nrow = Rstats::ArrayFunc::nrow(undef(), $x1)->value;
lib/Rstats/ArrayFunc.pm:  my $ncol = Rstats::ArrayFunc::ncol(undef(), $x1)->value;
lib/Rstats/ArrayFunc.pm:    return Rstats::ArrayFunc::c($x1->length_value);
lib/Rstats/ArrayFunc.pm:    return Rstats::ArrayFunc::c($x1->dim->values->[1]);
lib/Rstats/ArrayFunc.pm:  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
lib/Rstats/ArrayFunc.pm:  my $_along = $opt->{along};
lib/Rstats/ArrayFunc.pm:    my $length = $along->length_value;
lib/Rstats/ArrayFunc.pm:    $from = $opt->{from} unless defined $from;
lib/Rstats/ArrayFunc.pm:    $to = $opt->{to} unless defined $to;
lib/Rstats/ArrayFunc.pm:    my $length = $opt->{length};
lib/Rstats/ArrayFunc.pm:    my $by = $opt->{by};
lib/Rstats/ArrayFunc.pm:        $by = -1;
lib/Rstats/ArrayFunc.pm:      $by = ($to - $from) / ($length - 1);
lib/Rstats/ArrayFunc.pm:      $elements->[0] = $to;
lib/Rstats/ArrayFunc.pm:    my $type = $x1->vector->type || '';
lib/Rstats/ArrayFunc.pm:      $type_h->{character}++;
lib/Rstats/ArrayFunc.pm:      $type_h->{complex}++;
lib/Rstats/ArrayFunc.pm:      $type_h->{double}++;
lib/Rstats/ArrayFunc.pm:      $type_h->{integer}++;
lib/Rstats/ArrayFunc.pm:      $type_h->{logical}++;
lib/Rstats/ArrayFunc.pm:    if ($type_h->{character}) {
lib/Rstats/ArrayFunc.pm:    elsif ($type_h->{complex}) {
lib/Rstats/ArrayFunc.pm:    elsif ($type_h->{double}) {
lib/Rstats/ArrayFunc.pm:    elsif ($type_h->{integer}) {
lib/Rstats/ArrayFunc.pm:    elsif ($type_h->{logical}) {
lib/Rstats/ArrayFunc.pm:  ($x1, $x2) = Rstats::ArrayFunc::upgrade_type($x1, $x2) if $x1->vector->type ne $x2->vector->type;
lib/Rstats/ArrayFunc.pm:  my $x1_length = $x1->length_value;
lib/Rstats/ArrayFunc.pm:  my $x2_length = $x2->length_value;
lib/Rstats/ArrayFunc.pm:  my $x3_elements = $func->($x1->vector, $x2->vector);
lib/Rstats/ArrayFunc.pm:  $x3->vector($x3_elements);
lib/Rstats/ArrayFunc.pm:  $x1->copy_attrs_to($x3);
lib/Rstats/ArrayFunc.pm:  my $dim_values = $x1->dim_as_array->values;
lib/Rstats/ArrayFunc.pm:  my $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:      $e1 = $x1_elements->[$_[0] - 1];
lib/Rstats/ArrayFunc.pm:      $e1 = $x1_elements->[($_[0] + $dim_values->[0] * ($_[1] - 1)) - 1];
lib/Rstats/ArrayFunc.pm:      $e1 = $x1->get(@_)->decompose->[0];
lib/Rstats/ArrayFunc.pm:    $e1 = $x1_elements->[0];
lib/Rstats/ArrayFunc.pm:  return defined $e1 ? $e1->value : undef;
lib/Rstats/ArrayFunc.pm:  my $length = $x1->length_value;
lib/Rstats/ArrayFunc.pm:  my $type = $x1->type;
lib/Rstats/ArrayFunc.pm:  my $value = $x1->value;
lib/Rstats/ArrayFunc.pm:    Carp::croak 'Error in -a : invalid argument to unary operator ';
lib/Rstats/ArrayFunc.pm:    if ($value eq 'Inf' || $value eq '-Inf') {
lib/Rstats/ArrayFunc.pm:  my $at = $x1->at;
lib/Rstats/ArrayFunc.pm:    $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:    my $x2_elements = $x2->decompose;
lib/Rstats/ArrayFunc.pm:    my $levels_h = $x1->_levels_h;
lib/Rstats/ArrayFunc.pm:      my $pos = $poss->[$i];
lib/Rstats/ArrayFunc.pm:      my $element = $x2_elements->[(($i + 1) % @$poss) - 1];
lib/Rstats/ArrayFunc.pm:      if (Rstats::Func::is_na(undef(), $element)->value) {
lib/Rstats/ArrayFunc.pm:        $x1_elements->[$pos] = Rstats::VectorFunc::new_logical(undef);
lib/Rstats/ArrayFunc.pm:        my $value = $element->to_string;
lib/Rstats/ArrayFunc.pm:        if ($levels_h->{$value}) {
lib/Rstats/ArrayFunc.pm:          $x1_elements->[$pos] = $levels_h->{$value};
lib/Rstats/ArrayFunc.pm:          $x1_elements->[$pos] = Rstats::VectorFunc::new_logical(undef);
lib/Rstats/ArrayFunc.pm:    if ($x1->vector->type ne $x2->vector->type) {
lib/Rstats/ArrayFunc.pm:      $x1_tmp->copy_attrs_to($x1);
lib/Rstats/ArrayFunc.pm:      $x1->vector($x1_tmp->vector);
lib/Rstats/ArrayFunc.pm:    $x1_elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:    my $x2_elements = $x2->decompose;
lib/Rstats/ArrayFunc.pm:      my $pos = $poss->[$i];
lib/Rstats/ArrayFunc.pm:      $x1_elements->[$pos] = $x2_elements->[(($i + 1) % @$poss) - 1];
lib/Rstats/ArrayFunc.pm:  $x1->vector(Rstats::Vector->compose($x1->vector->type, $x1_elements));
lib/Rstats/ArrayFunc.pm:  my $levels = Rstats::Func::levels(undef(), $x1)->values;
lib/Rstats/ArrayFunc.pm:    $levels_h->{$levels->[$i - 1]} = Rstats::VectorFunc::new_integer($i);
lib/Rstats/ArrayFunc.pm:  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
lib/Rstats/ArrayFunc.pm:    $level_drop = $opt->{drop};
lib/Rstats/ArrayFunc.pm:    $dim_drop = $opt->{drop};
lib/Rstats/ArrayFunc.pm:    my $at = $x1->at;
lib/Rstats/ArrayFunc.pm:  $x1->at($_indexs);
lib/Rstats/ArrayFunc.pm:  my $x1_values = $x1->values;
lib/Rstats/ArrayFunc.pm:  my @a2_values = map { $x1_values->[$_] } @$poss;
lib/Rstats/ArrayFunc.pm:    Rstats::ArrayFunc::new_vector($x1->vector->type, @a2_values),
lib/Rstats/ArrayFunc.pm:  $x1->copy_attrs_to($x2, {new_indexes => $new_indexes, exclude => ['dim']});
lib/Rstats/ArrayFunc.pm:  my $x_is = $x1->length_value == 0 ? Rstats::ArrayFunc::TRUE() : Rstats::ArrayFunc::FALSE();
lib/Rstats/ArrayFunc.pm:  if (defined(my $vector = $x1->vector)) {
lib/Rstats/ArrayFunc.pm:    $x2->vector($x1->vector->is_nan);
lib/Rstats/ArrayFunc.pm:    $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  if (my $vector = $x1->vector) {
lib/Rstats/ArrayFunc.pm:    $x2->vector($x1->vector->is_infinite);
lib/Rstats/ArrayFunc.pm:    $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:  if (my $vector = $x1->vector) {
lib/Rstats/ArrayFunc.pm:    $x2->vector($x1->vector->is_finite);
lib/Rstats/ArrayFunc.pm:    $x1->copy_attrs_to($x2);
lib/Rstats/ArrayFunc.pm:    $levels = Rstats::Func::levels(undef(), $x1)->values;
lib/Rstats/ArrayFunc.pm:  my $values = $x1->values;
lib/Rstats/ArrayFunc.pm:  my $type = $x1->vector->type;
lib/Rstats/ArrayFunc.pm:  my $dim_values = $x1->dim_as_array->values;
lib/Rstats/ArrayFunc.pm:  my $dim_num = $dim_length - 1;
lib/Rstats/ArrayFunc.pm:      my $names = $x1->names->values;
lib/Rstats/ArrayFunc.pm:      my @parts = map { $x1->_value_to_string($_, $type, $is_factor) } @$values;
lib/Rstats/ArrayFunc.pm:      my $colnames = $x1->colnames->values;
lib/Rstats/ArrayFunc.pm:        for my $d2 (1 .. $dim_values->[1]) {
lib/Rstats/ArrayFunc.pm:          $str .= $d2 == $dim_values->[1] ? "[,$d2]\n" : "[,$d2] ";
lib/Rstats/ArrayFunc.pm:      my $rownames = $x1->rownames->values;
lib/Rstats/ArrayFunc.pm:      for my $d1 (1 .. $dim_values->[0]) {
lib/Rstats/ArrayFunc.pm:          my $rowname = $rownames->[$d1 - 1];
lib/Rstats/ArrayFunc.pm:        for my $d2 (1 .. $dim_values->[1]) {
lib/Rstats/ArrayFunc.pm:          my $part = $x1->value($d1, $d2);
lib/Rstats/ArrayFunc.pm:          push @parts, $x1->_value_to_string($part, $type, $is_factor);
lib/Rstats/ArrayFunc.pm:            $dim_num--;
lib/Rstats/ArrayFunc.pm:            $code->(@dim_values);
lib/Rstats/ArrayFunc.pm:            my $l_dimnames = $x1->dimnames;
lib/Rstats/ArrayFunc.pm:              my $x_dimnames = $l_dimnames->getin($i);
lib/Rstats/ArrayFunc.pm:              $dimnames = defined $l_dimnames ? $l_dimnames->values : [];
lib/Rstats/ArrayFunc.pm:                my $part = $x1->value($d1, $d2, @$poss);
lib/Rstats/ArrayFunc.pm:                push @parts, $x1->_value_to_string($part, $type, $is_factor);
lib/Rstats/ArrayFunc.pm:      $code->(@$dim_values);
lib/Rstats/ArrayFunc.pm:  my $x1 = $opt->{x};
lib/Rstats/ArrayFunc.pm:  my $elements = $x1->decompose;
lib/Rstats/ArrayFunc.pm:  my $x_dim = exists $opt->{dim} ? $opt->{dim} : NULL;
lib/Rstats/ArrayFunc.pm:  my $x1_length = $x1->length_value;
lib/Rstats/ArrayFunc.pm:  unless ($x_dim->vector->length_value) {
lib/Rstats/ArrayFunc.pm:  $dim_product *= $_ for @{$x_dim->values};
lib/Rstats/ArrayFunc.pm:  $x2->dim($x_dim);
lib/Rstats/ArrayFunc.pm:Rstats::ArrayFunc - Array functions
lib/Rstats/Vector.pm:use Object::Simple -base;
lib/Rstats/Vector.pm:Rstats::Vector - Vector
lib/Rstats/VectorFunc.pm:Rstats::VectorFunc - Vector functions
lib/Rstats.pm:  my $r = Rstats::Class->new;
lib/Rstats.pm:    *{"${class}::$method"} = sub { $r->$method(@_) }
lib/Rstats.pm:    *{"${class}::$method"} = sub () { $r->$method };
lib/Rstats.pm:  warnings->unimport('ambiguous');
lib/Rstats.pm:Rstats - R language build on Perl
lib/Rstats.pm:  my $x1 = r->sum(c(1, 2, 3));
lib/Rstats.pm:  r->helper(my_sum => sub {
lib/Rstats.pm:    for my $value ($x1->values) {
lib/Rstats.pm:  my $x2 = r->my_sum(c(1, 2, 3));
lib/Rstats.pm:  $x1->get(1)
lib/Rstats.pm:  $x1->get(1, 2)
lib/Rstats.pm:  $x1->get(c(1,2), c(3,4))
lib/Rstats.pm:  $x1->get(NULL, 2)
lib/Rstats.pm:  # x1[-1]
lib/Rstats.pm:  $x1->get(-1)
lib/Rstats.pm:  $x1->get(TRUE, FALSE)
lib/Rstats.pm:  $x1->get(c("id", "title"))
lib/Rstats.pm:  # x1[1] <- x2
lib/Rstats.pm:  $x1->at(1)->set($x2)
lib/Rstats.pm:  # x1[1, 2] <- x2
lib/Rstats.pm:  $x1->at(1, 2)->set($x2)
lib/Rstats.pm:  # x1[c(1,2), c(3,4)] <- x2
lib/Rstats.pm:  $x1->at(c(1,2), c(3,4))->set($x2)
lib/Rstats.pm:  # x1[,2] <- x2
lib/Rstats.pm:  $x1->at(NULL, 2)->set($x2)
lib/Rstats.pm:  # x1[-1] <- x2
lib/Rstats.pm:  $x1->at(-1)->set($x2)
lib/Rstats.pm:  # x1[TRUE, FALSE] <- x2
lib/Rstats.pm:  $x1->at(TRUE, FALSE)->set($x2);
lib/Rstats.pm:  # x1[c("id", "title")] <- x2
lib/Rstats.pm:  $x1->at(c("id", "title"))->set($x2);
lib/Rstats.pm:  # x1 - x2
lib/Rstats.pm:  $x1 - $x2
lib/Rstats.pm:  r->tranc($x1 / $x2)
lib/Rstats.pm:  r->abs($x1)
lib/Rstats.pm:  r->acos($x1)
lib/Rstats.pm:  r->acosh($x1)
lib/Rstats.pm:  r->asin($x1)
lib/Rstats.pm:  r->asinh($x1)
lib/Rstats.pm:  r->atan($x1)
lib/Rstats.pm:  r->atanh($x1)
lib/Rstats.pm:  r->cbind(c(1, 2), c(3, 4), c(5, 6));
lib/Rstats.pm:  r->ceiling($x1)
lib/Rstats.pm:  r->col($x1)
lib/Rstats.pm:  r->colMeans($x1)
lib/Rstats.pm:  r->cos($x1)
lib/Rstats.pm:  r->cosh($x1)
lib/Rstats.pm:  r->exp($x1)
lib/Rstats.pm:  r->expm1($x1)
lib/Rstats.pm:  r->floor($x1)
lib/Rstats.pm:  r->log($x1)
lib/Rstats.pm:  r->logb($x1)
lib/Rstats.pm:  r->log2($x1)
lib/Rstats.pm:  r->log10($x1)
lib/Rstats.pm:  r->ncol($x1)
lib/Rstats.pm:  r->nrow($x1)
lib/Rstats.pm:  r->rbind(c(1, 2), c(3, 4), c(5, 6))
lib/Rstats.pm:  r->round($x1)
lib/Rstats.pm:  r->round($x1, $digits)
lib/Rstats.pm:  r->round($x1, {digits => TRUE});
lib/Rstats.pm:  r->row($x1)
lib/Rstats.pm:  r->rowMeans($x1)
lib/Rstats.pm:  r->rowSums($x1)
lib/Rstats.pm:  r->sin($x1)
lib/Rstats.pm:  r->sinh($x1)
lib/Rstats.pm:  r->sqrt($x1)
lib/Rstats.pm:  r->t($x1)
lib/Rstats.pm:  r->tan($x1)
lib/Rstats.pm:  r->tanh($x1)
lib/Rstats.pm:  r->trunc($x1)
lib/Rstats.pm:  r->as_array($x1)
lib/Rstats.pm:  r->as_character($x1)
lib/Rstats.pm:  r->as_complex($x1)
lib/Rstats.pm:  r->as_integer($x1)
lib/Rstats.pm:  r->as_list($x1)
lib/Rstats.pm:  r->as_logical($x1)
lib/Rstats.pm:  r->as_matrix($x1)
lib/Rstats.pm:  r->as_numeric($x1)
lib/Rstats.pm:  r->as_vector($x1)
lib/Rstats.pm:  r->is_array($x1)
lib/Rstats.pm:  r->is_character($x1)
lib/Rstats.pm:  r->is_complex($x1)
lib/Rstats.pm:  r->is_finite($x1)
lib/Rstats.pm:  r->is_infinite($x1)
lib/Rstats.pm:  r->is_list($x1)
lib/Rstats.pm:  r->is_matrix($x1)
lib/Rstats.pm:  r->is_na($x1)
lib/Rstats.pm:  r->is_nan($x1)
lib/Rstats.pm:  r->is_null($x1)
lib/Rstats.pm:  r->is_numeric($x1)
lib/Rstats.pm:  r->is_double($x1)
lib/Rstats.pm:  r->is_integer($x1)
lib/Rstats.pm:  r->is_logical($x1)
lib/Rstats.pm:  r->is_vector($x1)
lib/Rstats.pm:  r->labels($x1)
lib/Rstats.pm:  r->levels($x1)
lib/Rstats.pm:  # levels(x1) <- c("F", "M")
lib/Rstats.pm:  r->levels($x1 => c("F", "M"))
lib/Rstats.pm:  r->dim($x1)
lib/Rstats.pm:  # dim(x1) <- c(1, 2)
lib/Rstats.pm:  r->dim($x1 => c(1, 2))
lib/Rstats.pm:  r->names($x1)
lib/Rstats.pm:  # names(x1) <- c("n1", "n2")
lib/Rstats.pm:  r->names($x1 =>  c("n1", "n2"))
lib/Rstats.pm:  r->nlevels($x1)
lib/Rstats.pm:  r->dimnames($x1)
lib/Rstats.pm:  # dimnames(x1) <- list(c("r1", "r2"), c("c1", "c2"))
lib/Rstats.pm:  r->dimnames($x1 => list(c("r1", "r2"), c("c1", "c2")))
lib/Rstats.pm:  r->colnames($x1)
lib/Rstats.pm:  # colnames(x1) <- c("r1", "r2")
lib/Rstats.pm:  r->colnames($x1 => c("r1", "r2"))
lib/Rstats.pm:  r->rownames($x1)
lib/Rstats.pm:  # rownames(x1) <- c("r1", "r2")
lib/Rstats.pm:  r->rownames($x1 => c("r1", "r2"))
lib/Rstats.pm:  r->mode($x1)
lib/Rstats.pm:  # mode(x1) <- c("r1", "r2")
lib/Rstats.pm:  r->mode($x1 => c("r1", "r2"))
lib/Rstats.pm:  r->str($x1)
lib/Rstats.pm:  r->typeof($x1);
